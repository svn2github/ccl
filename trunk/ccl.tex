
% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

% Example of the Memoir class, an alternative to the default LaTeX classes such as article and book, with many added features built into the class itself.

\documentclass[12pt,a4paper]{memoir} % for a long document
%\documentclass[12pt,a4paper,article]{memoir} % for a short document
\usepackage{makeidx}
\makeindex
\usepackage[utf8]{inputenc} % set input encoding to utf8
\usepackage{moreverb}
%\usepackage{listings}
%\usepackage{tikz}
%\usepackage{utopia}
%\usepackage[explicit]{titlesec}

%\lstset{language=C,basicstyle=\ttfamily,numbers=left,numberstyle=\tiny}
% Don't forget to read the Memoir manual: memman.pdf

%%% Examples of Memoir customization
%%% enable, disable or adjust these as desired

%%% PAGE DIMENSIONS
% Set up the paper to be as close as possible to both A4 & letter:
%\settrimmedsize{297mm}{210mm}{*} % letter = 11in tall; a4 = 210mm wide
%\setlength{\trimtop}{0pt}
%\setlength{\trimedge}{\stockwidth}
%\addtolength{\trimedge}{-\paperwidth}
%\settypeblocksize{*}{\lxvchars}{1.618} % we want to the text block to have golden proportionals
%\setulmargins{50pt}{*}{*} % 50pt upper margins
%\setlrmargins{*}{*}{1.618} % golden ratio again for left/right margins
%\setheaderspaces{*}{*}{1.618}
%\setheadfoot{\onelineskip}{2\onelineskip}
%\checkandfixthelayout 

\settrimmedsize{297mm}{210mm}{*}
\setlength{\trimtop}{0pt}
\setlength{\trimedge}{\stockwidth}
\addtolength{\trimedge}{-\paperwidth}
\settypeblocksize{634pt}{448.13pt}{*}
\setulmargins{4cm}{*}{*}
\setlrmargins{30mm}{*}{*}
\setmarginnotes{17pt}{51pt}{\onelineskip}
\setheadfoot{\onelineskip}{2\onelineskip}
\setheaderspaces{*}{2\onelineskip}{*}
\checkandfixthelayout
% This is from memman.pdf
%%% \maketitle CUSTOMISATION
% For more than trivial changes, you may as well do it yourself in a titlepage environment
\pretitle{\begin{center}\sffamily\huge\MakeUppercase}
\posttitle{\par\end{center}\vskip 0.5em}

%%% ToC (table of contents) APPEARANCE
\maxtocdepth{subsection} % include subsections
\renewcommand{\cftchapterpagefont}{}
\renewcommand{\cftchapterfont}{}     % no bold!

%%% HEADERS & FOOTERS
\pagestyle{ruled} % try also: empty , plain , headings , ruled , Ruled , companion

%%% CHAPTERS
\chapterstyle{hangnum} % try also: default , section , hangnum , companion , article, demo

\renewcommand{\chaptitlefont}{\Huge\sffamily\raggedright} % set sans serif chapter title font
\renewcommand{\chapnumfont}{\Huge\sffamily\raggedright} % set sans serif chapter number font

%%% SECTIONS
\hangsecnum % hang the section numbers into the margin to match \chapterstyle{hangnum}
\maxsecnumdepth{subsection} % number subsections

\setsecheadstyle{\Large\sffamily\raggedright} % set sans serif section font
\setsubsecheadstyle{\large\sffamily\raggedright} % set sans serif subsection font

%% END Memoir customization
\newcommand{\raisedrule}[2][0em]{\leaders\hbox{\rule[#1]{1pt}{#2}}\hfill}

\title{A container library for C}
\author{Jacob Navia}
\date{} % Delete this line to display the current date
\usepackage{xargs}
\usepackage{color}
%\renewcommandx*{\hrulefill}[2][0pt]{\leavevmode \leaders \hbox to 1pt{\rule[#1]{1pt}{#2}} \hfill \kern 0pt}

\renewcommandx*{\hrulefill}[2][1=0.3mm,2=0pt]{\leavevmode \leaders \hbox to 1pt{\rule[#2]{1pt}{#1}} \hfill \kern 0pt}
\definecolor{purple}{rgb}{0.42,0.12,1.0}

%--------------------------------------------------API
\newcommand{\api}[1] {%
\par\vspace{0.4cm}
\addcontentsline{toc}{subsubsection}{#1}\index{#1}
%\par\noindent
\noindent {\large \textbf{#1}}\index{#1} \hrulefill[1pt][3.5pt]
\nopagebreak
\begin{verbatim}
}
%% --------------------------------------- Function command
\newcommand{\function}[1] {%
\vspace{0.2in}
\par\noindent
\textbf{#1}\index{#1!code for \container} \hrulefill
\nopagebreak
\noindent\begin{verbatim}}

%% Description command
\newcommand{\apidescription}{%
\par \noindent \textbf{Description:} %\par\noindent
}
\newcommand{\notes}{
\par \noindent \textbf{Notes:}\par\noindent}

\newcommand{\apierrors}{%
\par \noindent \textbf{Errors:}\par\noindent
}
\newcommand{\doerror}[1]{%
\par\noindent
{\footnotesize CONTAINER\_ERROR\_#1}
}
\newcommand{\Null}{
{\footnotesize NULL}
}

\newcommand{\returns}{%
\par\noindent \textbf{Returns:} %\par\noindent
}
\newcommand{\example}{
\par\noindent
\textbf{Example:}
\begin{verbatim}
}
\newcommand{\See}[1]{%
see \ref{#1} on page~\pageref{#1}
}

%%% BEGIN DOCUMENT
\begin{document}
\setcounter{tocdepth}{5}
\maketitle
\cleardoublepage
\tableofcontents* % the asterisk means that the contents itself isn't put into the ToC
%--------------------------------------------------------------------------------------------------------------------------
%                                                   INTRODUCTION
%--------------------------------------------------------------------------------------------------------------------------
\chapter{Introduction}
The objective of this proposal is to standardize the usage of common data structures within the context of the C language. The existence of a common standard interface for lists, hash tables, flexible arrays, and other containers has several advantages:
\begin{itemize}
\item
User code remains portable across machines and operating systems
\item
The portable specifications provide a common framework for library writers and compiler/system designers to build compatible yet strongly specialized implementations.
\item
The language becomes more expressive: it is not necessary to build the nth hash table function from scratch. You can use a standard one.
\end{itemize}
The big innovation of C in the eighties was its standard library, that made input/output portable across machines and implementations. The container library would replicate again that idea, at a higher level.

The specifications presented here are completely scoped by the C99 specifications, and can be implemented even in compilers that do not implement C99 and stayed within the C90 context. No language extensions are needed nor any are proposed.
\footnote{After spending several years working implementing C99, I was very disappointed that the committee started taking back some improvements of C99, making them optional. This is principally the work of Mr Plauger, that works with Microsoft, a company that never implemented the C99 standard and was one of the reasons of its failure to catch on. This individual has a big influence in the committee, and has suceeded in eliminating several features of C99. Since I am not sure which items of C99 will resist the assaults of Plauger, I decided to avoid it. }

The interfaces proposed try to present complete packages, i.e. interfaces with all the necessary functions to allow the widest usage: Serialization, searching, and many other functionalities are included in the proposed standard to allow for maximum code portability. It can be argued that this makes  for "fat" containers, but if you read carefully you will notice that many things can be left out in systems that run in low memory or with feeble computing power.

This documentation is composed of several parts:
\begin{enumerate}
\item An introductory part where the general lines of the library are explained.
\item A specifications part where each function of the library is fully specified. This is the proposal for the next C standard.
\item An "examples" part that shows the uses of the library and allows you to have a better idea of how the usage of the library looks like.
\item An implementation part where the code of the sample implementation is discussed. This is designed as a guide for implementors to give them a basis to start with.
\end{enumerate}
\section{Containers}
In the context of this library, a container is a data structure used to organize data within a single logical object that allows for adding, searching and removing data. The data is not further specified. It can be anything, images, numbers, text, whatever. The only thing that the container knows is the size of the data, if we store a series of objects of the same size, or its address, if we store objects of different sizes. In the later case we store just a pointer in the container.
Each container has a way of iterating through all its elements by using an “iterator” auxiliary object, that returns each stored object in sequence.

All objects stored by the library are copied into the library, and the library is responsible for the management of the associated storage. If you do not want this, just store a pointer to the data and manage the data yourself.

We have basically two different kinds of containers
\begin{itemize}
\item
1. Sequential containers
\item
2. Associative containers
\end{itemize}

A sequential container is organized in a linear order. We have a sequence starting at index zero up to the number of elements stored. Data items can be retrieved by index, and it makes sense to speak of a “next” and a “previous” element.

Sequential containers can be contiguous (arrays) or disjoint (lists). In the first case access is very fast since it implies multiplying the index by the size of each element to get to any position in the data. In the second case access the nth element can be a lengthy operation since the chain of “next” or “previous” pointers must be followed for each access to a given position.

An associative container stores an object divided in two parts: a key, that is used as a token for the data, and the data itself. It associates key/value pairs. Speed of access is fast, but not linear, and can degrade as new items are stored in it.

In all cases, we have some basic properties of an abstract container that are common to all of them. 
\begin{itemize}
\item
A function to report errors. This function (like all other function pointers) can be changed, and defaults to a simple error function that prints the error in the standard output stream. 
\item
Each change in a container is recorded. This permits to validate pointers to a container: if the container has changed after the creation of the pointer, the pointer could be invalid.
\item
All containers use a standard object to allocate and manage memory. This object must be set previously to calling any creation function. Each container has in its methods table a pointer to a specific allocator object.   Any change is understood as a change to the class of objects that uses the allocator, i.e. it is valid for all containers created after the change. It is possible to change a single container without changing the allocator by copying the methods table for this container first, then changing the allocator.
\end{itemize}

Managing a sequence involves trade offs what performance is concerned. If the usage will involve frequent insertion and deletion of objects you will prefer a container that handles those operations in constant time: the time to add or delete an object doesn't increase with the number of elements in the container. Such a container will be unlikely to provide also access to a given element in constant time. Access is likely to be much slower, and what you gain in flexibility you loose in another dimension. It is the user of the library, the programmer, that decides what container fits best the intended usage.

Since usage patterns change, however, the library tries to ensure that you can change the container you are using with minimal effort. If at the beginning of an application a list looked like a good solution but later an array, that provides constant time access is better suited, you can change the type of container without changing every line that uses it. The common vocabulary of the library makes this possible.

\section{The interface concept}
Each container is defined by its interface, i.e. the table of functions it supports For each interface, its name is composed of a lower case “i” followed by the container name: iList, iVector, iStringCollection, etc.

Each function of the interface receives always the container as its first argument. Obviously, the big exception is the creation function, that receives various arguments depending of which container or from what input, the container is to be created.

For each container interface a global object exists that allows direct access to the function table without the need of creating a container to access it.

This interface allows for simple access to each container using a very similar vocabulary:
\begin{verbatim}
iList.Add(list,object);
iStringCollection.Add(strcol,object);
\end{verbatim}
The objects stored in a container have always the same size. When storing objects of different sizes just store a pointer to the objects, since pointers have always the same size.
\section{Error handling}
This specification describes the basic error handling that each function of the library must do. Other errors can appear in different implementations.
At each error, the library should call the container instance specific error handling when there is one, or call the general error handling function in the iError interface. When it is not possible to call the instance specific error function, for instance when the instance parameter is\Null, the library calls the general error handling function in the iError interface\footnote{There is no automatic cleanup of objects left by active functions in the stack. This can be a problem or not, depending if your use a garbage collection or not. If you use a garbage collector, this problem doesn't even appear: the unused objects will be automatically collected. If you don't, you should test for the return code of each function.}.

The user of the library can either replace the default iError interface with a function that handles the error with a jump to a previously set recovery point, or treat the error locally using the return code. All errors are negative constants, it suffices to test if the result is less than zero.
 
The error codes defined by this specification are:
\index{error-codes}
\begin{itemize}
\item
\doerror{BADARG} One of the parameters passed to a function is invalid.
\item
\doerror{NOMEMORY} There is not enough memory to complete the operation.
\item
\doerror{INDEX} The index is out of bounds.
\item
\doerror{READONLY} The object is readonly and the operation is not allowed.
\item
\textsc{CONTAINER\_INTERNAL\_ERROR} Unspecified error provoked by a problem in the implementation.
\item
\doerror{OBJECT\_CHANGED} A change in the underlying object has invalidated an iterator.
\item
\doerror{NOT\_EMPTY} Operation can be performed in an object with no elements only.
\item
\doerror{FILE\_READ} Input error in a stream.
\item
\doerror{FILE\_WRITE} Output error in a stream.
\item
\doerror{CONTAINER\_FULL} Implementations can limit the maximum number of elements a container can hold. This error indicates that the limit is reached.
\end{itemize}

Other errors can be defined by each implementation.

The treatment of each error is done in the object defined by the \texttt{iError} interface.

\section{The different containers}
All data structures in this section are known and used for several decades. Lists are a common feature of any data processing task since the sixties for instance. 
The library provides for abstract containers, and some examples of concrete ones for the elementary types.
We have:
\begin{itemize}
\item
Vectors. The general abstract vector container is implemented in the “Vector” container. This is a flexible array that allows for insertion/deletions, with no cost for insertion at the end in most cases. Concrete implementations for the elementary types are provided for bits (bit-strings), strings (null terminated), int/double/long double numeric data in the form of templates.
\item
Lists. Single linked lists (List) and double linked lists (Dlist) are provided.
\item
Queue, Deque
\item
Trees (red/black trees, AVL trees)
\item
Dictionary. This is a simple implementation of a hash table with character keys.
\item
Hash Table. More complex implementation of a hash table with arbitrary (binary) keys, and automatic hash table resizing.
\end{itemize}
\subsection{ Single and double linked lists}
This containers consist of a header and a list of elements containing each a pointer to the next element in the chain, and a pointer to the data item stored. The end of the list is marked by a node that contains a\Null “next” pointer. Double linked lists contain an additional pointer to the previous element.

This is a very flexible container, allowing you to add and delete elements easily just by rewriting some pointers. You can even split them in two sublists just by zeroing somewhere the “next” pointer.

The price you pay for this flexibility is that sequential access is expensive, the cost of accessing the nth element increases linearly with n.

Storage overhead is one or two pointers per element stored in the list for single/double linked lists..

The data is stored directly after the pointer, there is no pointer to the data. This is a variable length structure with a fixed and a variable part. 
To avoid using a standard C99 feature that could be absent in older compilers, we use a semi-generic pointer indexed either by one (for older compilers) or by nothing (standard C) .

\subsection{Flexible arrays (vector)}
This container is an array with added operations that allow the user to insert and delete elements easily. It will resize itself if needed.

The access time is essentially the same as with a normal array. Insertion and deletion are possible but they are in general more expensive than with lists since the container must copy the elements to make place for a new element or to delete an element. An exception to this rule is the deletion of the last element that will be done in constant time since it implies only decrementing the number of elements in the container.

The storage overhead for each element is zero since this container doesn't require any pointers per object stored.

This container uses a reserve storage to avoid allocating new memory for each addition operation. This allows the “Add” operation to be done in constant time in most occasions.
\subsection{String collection}
This container is designed to handle a collection of C strings. It is essentially an application of the flexible array container with some extra functionality to handle strings.
\subsection{Bit-string}
This container is designed to handle arbitrary sequences of bits. Some algorithms that are easy to program with strings are much more complicated for bit-strings, like to one that mimics "strstr" ("bit-strstr"). 

The bits are packed with 8 bits per character unit. The overhead per bit is the size of the bit-string header only. No pointers are associated with each bit.

\subsection{Dictionary}
This is an associative container based on a hash table. It associates a text key with some arbitrary data. This container is not ordered. Access time to each element depends on how much elements are stored in it and on the efficacy of the hash function to maintain elements in different slots. Storage overhead per element is one pointer each, plus the size of the slot table. This is for a hash table with linked lists in each slot for managing collisions. Other implementations exist of course.
\subsection{Hash Table}
This is a more sophisticated version of the dictionary hash table. It allows for keys of binary data and it has automatic resizing in case the table gets too crowded.
\subsection{AVL trees}
This data structure allows for fast searching for data. You can store millions of records and find a given record with a few comparisons.
\subsection{“Scapegoat” trees}
This is another form of trees. They can be more efficient than AVL trees, but from a container perspective they share the same characteristics.
\subsection{Bloom Filter}
This is a probabilistic data structure used to quickly check if an element is not in a larger set of elements. It returns false positives with a given probability set when the container is built. Elements can be added to it but they can't be removed from the container. It stores no data, just a key.
\subsection{Queue}
Queues are designed to operate in a FIFO context (first-in first-out), where elements are inserted into one end of the container and extracted from the other. This container can be implemented as an adaptor using a single linked list as its base container. The sample implementation uses this strategy to show how adapters can look like. Other implementations can implement this container directly presenting the same interface.
\subsection{Deque}
This is a linear container that allows for cheap insertions/deletions at both ends.

\section{Types used by the library}
\subsection{CompareInfo}
\begin{verbatim}
typedef struct tagCompareInfo {
    void *ExtraArgs;
    void *Container;
} CompareInfo;
\end{verbatim}
This structure will be passed to the comparison functions. The “ExtraArgs” pointer will receive the pointer that was passed to the calling function. The “Object” pointer will receive the address of the container where the elements are stored. If the two elements being compared are in different containers, this pointer will be\Null.
\subsection{CompareFunction}
\begin{verbatim}
typedef int (*CompareFunction)(const void *elem1, 
                               const void *elem2, 
                               CompareInfo *ExtraArgs);
\end{verbatim}
This type defines the function used to compare two elements.
The result should be less than zero if elem1 is less than elem2, zero if they are equal, and bigger than zero if elem1 is bigger than element 2.
\subsection{SaveFunction}
\begin{verbatim}
typedef int (*SaveFunction)(const void *element, 
                               void *ExtraArg, 
                               FILE *OutputStream);
\end{verbatim}
This function should save the given element into the given stream.  The “ExtraArg” argument receives the address of the container and any argument passed to the Save function.
The result should be bigger than zero if the operation completed successfully, zero or less than zero otherwise.
\subsection{ReadFunction}
\begin{verbatim}
typedef int (*ReadFunction)(void *element, 
                               void *arg, 
                               FILE *InputStream);
\end{verbatim}
This function should read into the given element from the given stream. The “ExtraArg” argument is passed to the container Save function and allows to pass an argument to the user defined save function.
The result should be bigger than zero if the operation completed successfully, zero or less than zero otherwise.
\subsection{ErrorFunction}
\begin{verbatim}
typedef void (*ErrorFunction)(const char *functionName,int code);
\end{verbatim}
This function type is used to handle errors in each container. The first argument is the function name where the error occurred, the second is a negative error code.
%
%---------------------------------------------------------------------------Design Goals
%
\section{Design goals}
\subsection{Error analysis}
It has been a  tradition in C to place raw performance as the most important quality of specifications. To follow this sacred cow, the C standard
\footnote{The C++ standard too.} ignores any error analysis arguing that any specification of failure modes would damage "performance". This was
so ingrained in the whole specifications tradition, that the C standard document contained a buffer overflow in its sample code during at 
least 20 years.

This kind of mental framework was described by one of the people in the discussion group "comp.lang.c++" as follows:\footnote{We were discussing 
the specifications of the \texttt{mismtach} function of the C++ STL and why any error analysis is absent. The C++ STL prescribes a bounded 
region for the first container, but just a starting point for the second one. If the second is shorter than the specified range of the first
 \textsl{undefined behavior} ensues and anything can happen. In many cases this "anything" is different each time the same error occurs. In our
specific case \texttt{mismatch} would read from memory that doesn't belong to the container it started with. Depending on the contents of
that memory a crash could happen, or worst, a wrong result returned to the calling software, etc.}
\begin{quotation}
 In C++, the program is responsible for ensuring that \textbf{all} parameters to
 the standard library functions are valid, not only the third parameter of
 \texttt{std::mismatch()}. For example, also the first range for \texttt{std:mismatch()}
 must be valid, one may not pass a start iterator from one container and
 end iterator from another, for example. However, STL does not guarantee
 any protection against such errors, this is just UB.
\end{quotation}
This specifications try to break away from that frame of thought. Each function specifies a minimal subset of failure modes as a consequence of its error analysis. This 
is allows user code to:
\begin{itemize}
\item Detect and handle errors better.
\item Ensure that errors will always have the \textbf{same} consequences. One of the worst consequences of undefined behavior is that the same error can 
have completely different consequences depending on apparently random factors like previous contents of memory or previous allocation pattern.
\end{itemize}

At the same time, the mandatory error checking consists mainly of checks that can be implemented with a few integer comparisons. For instance a check 
for zero is a single instruction in most processors. If implemented correctly the conditional jump after the comparison with zero is not taken in the 
normal case and correctly predicted by the processor. This means that the pipeline is not disturbed and the cost for the whole operation is much less than a cycle.

Why is error analysis an essential part of any program specifications?

Because \textbf{mistakes are a fact of life}. Good programmers are good most of the time only. Even very good programmers \textsl{do make mistakes\footnote{Donald Knuth, the author of the TeX typesetting program can be without doubt be qualified as a good programmer (and an excellent computer scientist). But he, like anybody else, is not without flaws. See: 
www.tug.org/texmf-dist/doc/generic/knuth/errata/errorlog.pdf. There are hundreds of entries in that log.}.} Software
must be prepared to cope with this fact in an orderly fashion because if failure modes are not specified they have catastrophic consequences and lead
to brittle software that crashes randomly.

Note that error \textsl{analysis} is not error \textsl{handling}. Error handling is taking an action after an error, a task only the application can do.
What the library can do is to establish a framework where a user defined procedure receives enough information about the specific problem at hand.

Error analysis means that for each function and each API:
\begin{itemize}
\item An analysis is performed of what are the consequences of any error in its inputs. Error codes are used to pass detailed error information
to the error procedure.
\item During its execution, an analysis is done of each step that can fail.
\item The outputs of the function are left in a consistent state, errors provoking the undo of the previous steps in most cases, leaving the inputs
as they were before the function was called. This feature allows library functions to be restartable after an error. For instance an out of memory
condition can be corrected by freeing memory and retrying.
\end{itemize}
The library provides hooks for the users that can control each step and provide functions that can do the error handling, for instance logging the
error and jumping to a pre-established recovery point.
\subsection{Full feature set}
Another design goal is to offer to the user a full feature set, complete with serializing, iterators, search, read-only containers and all the features 
needed in most
situations. Other features are planned for later (observers, multi-threading support).
\subsection{Abstraction}
The library is designed with the possibility of implementing abstraction like serial and associative containers that allow software to treat several 
containers in a way that abstract most of their features, improving code reuse by allowing to implement algorithms for a class of objects. This is
specially true in the iterators feature.

It can be argued that the C language lacks many of the abstractions constructs of other languages like templates, inheritance, and many others.
All that is true, but the objective of this proposal is to show that those constructs are just an aid to developing abstractions, an aid that
is paid in added complexity for the resulting language, and in a limitation of what is feasible within a given framework. Since C has no 
framework, no preferred inheritance model, it is possible to create abstractions that are quite unconstrained: there is no framework precisely.
\subsection{Performance} Even with all the tests, the performance of the library has been maintained at a high level compared to similar libraries
in other languages. The performance should improve if standardized because compiler writers could specialize their optimizations targetting this
code.
%-----------------------------------------------------------------------------------------------------------
%                                                       Typographical conventions
%-----------------------------------------------------------------------------------------------------------
\section{How the functions are specified in this document.}
The specifications part of the proposal uses the same building blocks for each of the functions proposed.\par\noindent
\textbf{Name}

\noindent The name of the function. Note that when using this name, the container interface should be always before: 
iList.Add, iDictionary.Add, etc.

\noindent The name is followed by the prototype defined as a function pointer. For the function”Add” of the container “List” we have
\begin{verbatim}
    int (*Add)(List *list,void *data);
\end{verbatim} 
This means that “Add” is a function pointer in the interface iList. It would be used as:
\texttt{iList.Add(list,data)}.
\apierrors
The minimal set of errors that can appear during the execution of the function is listed. Each implementation is free to add implementation specific errors to this list. Note that how the library behaves after an error is defined by the current error function in the container (if any), then by the behavior of the error function in the iError interface. This can be changed by the user by using the iError interface.
\returns
The return value of the operation. Normally, negative values are error codes, positive values means success, and zero means non fatal errors, more in the sense of a warning.
%--------------------------------------------------------------------------------------------------------------------------
%                                        THE COMMON VOCABULARY
%--------------------------------------------------------------------------------------------------------------------------
\chapter{The common vocabulary: iGenericContainer}
The library uses always the same words to represent similar actions in all containers. 
\section{Creation of a container: Create}
Containers are created with a call to their “Create” function.  The first argument is the size of the objects that will be stored in the container. The second is optional and is a hint to the number of elements that will be stored in the container.
Note that if you want to store objects of different sizes you just store a pointer to those objects instead of the objects themselves.
The creation functions can have several arguments, the first being always the size of the elements that the container will hold. The prototype can be:
\begin{verbatim}
Container * iContainer.Create(size_t elementsize,...);
\end{verbatim}
The creation function needs to allocate memory to hold the container. This memory will be allocated using the current memory manager that is always an implicit argument to all creation functions. The rationale behind this design decision is that you don't change your memory allocation strategy at each call to a container creation function. This simplifies the interface at the expense of making the change of allocation strategy more expensive.

\section{Destruction of a container: Clear and Finalize}
All containers support two cleanup functions:
\begin{enumerate}
\item
Clear: remove all elements. The header structure remains untouched. This can be used to free the memory when the container was created with the \texttt{Init} function.
\item
Finalize: Remove all elements and the memory used by the container object using the allocator for this container. The container should NOT have been created using the \texttt{Init} function.
\end{enumerate}
The syntax is:
\begin{enumerate}
\item \texttt{int iContainer.Clear(Container *);}
\item \texttt{int iContainer.Finalize(Container *);}
\end{enumerate}
The result of those functions is less than zero when something goes wrong, greater than zero otherwise.
\subsection{Other creation functions}
\begin{enumerate}
\item
An implicit argument to all the creation functions is the current allocator, that is used to retrieve space for the container being built. To avoid changing the current allocator, what in multi-threaded environment would need acquiring a lock to that global variable, some containers support a creation function that receives an extra argument: a custom allocator.
\begin{verbatim}
Container * iContainer.CreateWithAllocator(size_t elementsize,
                          ContainerMemoryManager *allocator, ...);
\end{verbatim}
\item
Sometimes it can be useful for some containers (specially lists) to create the  header structure using an already existing space, for instance in the space for local variables. For this an 'Init' function can exist, that initializes a container within an existing space.
Since normally the detailed structure (and the size of course) of each container header is implementation dependent, you use the Sizeof function with an argument of\Null to get the size of the header. This can be used within a C99 compiler environment to allocate the space for that variable.
\footnote{This incredibly useful feature has been made now optional by the C99 committee, even if it was mandatory when the C99 standard was published.}
The declaration of the container header in C99 would be:
\begin{verbatim}
int function(void)
{
    char listSpace[iList.Sizeof(NULL)];
    iList.Init(listSpace);
}
\end{verbatim}
If C99 is not available, the best way is to just print the size of the container you are interested in, and then use that value that should stay fixed for a given version. This can be automated and you can find in the Appendix 1, a small program that generates a series of \texttt{\#defines} with the values of the sizes of the containers described in this documentation.
\end{enumerate}
\section{Adding an element to a container: Add}
This operation adds the given element to a container. In sequential containers it is added at the end, in associative containers it is added at an unspecified position.

\texttt{int iContainer.Add(Container *, void *element);}

The result of this operation is an integer with the number of elements in the container after the addition or an error code less than zero if the operation fails.
\section{Removing an element from a container: Erase}
Removes the given element from the container. The result is an integer greater or equal to zero with the number of elements in the container after the remove operation, or an error code less than zero if the element couldn't be added.
\begin{verbatim}
int iContainer.Erase(Container *,void *element);
\end{verbatim}
\noindent This function needs to search for the given element before erasing it. For sequential containers you can use the “RemoveAt” function, that will remove a container at a given position.

\begin{verbatim}
int iContainer.EraseAt(Container *,size_t idx);
\end{verbatim}
\noindent
For associative containers you use RemoveKey:

\begin{verbatim}
int iContainer.RemoveKey(Container *,void *Key);
\end{verbatim}

\section{Retrieving an element from a container: GetElement}
The GetElement function retrieves an element from a container. It comes in two different flavors, one for sequential containers, and another for associative ones.
\begin{verbatim}
void *iContainer.GetElement(Container *,size_t index);
void *iContainer.GetElement(Container *,void *Key);
\end{verbatim}
These functions return a pointer to the requested element or\Null if the element can't be retrieved. The resulting pointer points directly to the data stored in the container. This could be used to bypass all the flags that control the access to the container. For read-only containers, use the \texttt{CopyElement} function that returns a copy of the requested data into a buffer.
\section{Sorting a sequential container: Sort}
The “Sort” function will sort a container in place. To keep the old, unsorted contents, make a copy of the container first.
\begin{verbatim}
int iContainer.Sort(Container *);
\end{verbatim}
\section{Copying a container: Copy}
\noindent The “Copy” function will make a fresh copy of a container. Some fields of the header are copied: the error and compare functions, the flags, and others. Memory will be allocated withe the source container allocator.
\begin{verbatim}
newContainer * iContainer.Copy(Container *);
\end{verbatim}
\section{Saving and loading a container to or from disk: Save and Load}
The functions “Save” and “Load” will save / load the contents, state, and characteristics of a container into / from disk. They need an open file stream, open in binary mode, and in the correct direction: saving needs a stream open in the write direction, loading needs a stream open in the read direction.
\section{Inserting a container into another: InsertIn}
\subsection{Sequential containers}
\noindent
\begin{verbatim}
int (*InsertIn)(Container *destination,
                size_t position,
                Container *source);
\end{verbatim}
This function will insert into the "destination" container the contents of the "source" container at the given position. The source is not modified in any way, and a copy of its data will be used. Both containers must be of the same type and store elements of  the same type. The library only tests the element size of each one.
\subsection{Associative containers}
\begin{verbatim}
int (*InsertIn)(Container *destination, Container *source);
\end{verbatim}
This function will insert into the destination container the source container using the source container keys. Otherwise the same conditions apply as to the sequential containers: the containers must be of the same type and store elements of the same type.
\section{Replace an element with another}
\subsection{Sequential containers: ReplaceAt}
\begin{verbatim}
int (*ReplaceAt)(Container *dst,size_t position,void *newData);
\end{verbatim}
Replaces the element at the given position with the new data. 
\subsection{Associative containers: Replace}
\begin{verbatim}
int (*Replace)(Dictionary *Dict, const unsigned char *Key,void *Value);
\end{verbatim}
Replaces the element with the given key. If the element is absent nothing is done.
\section{Looping through all elements of a container}
The user has  three methods for looping through all elements:
\begin{enumerate}
\item Using a simple loop construct
\item Using the “Apply” function
\item Using an iterator
\end{enumerate}
One the most familiar design patterns  is the ITERATOR pattern, which ‘provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation’. 

Traditionally, this is achieved by identifying an ITERATOR interface that presents operations to initialize an iteration, to access the current element, to advance to the next element, and to test for completion; collection objects are expected to implement this interface, usually indirectly via an auxiliary object. 

This is exactly the case in the iterator proposal here. Essential to the pattern is the idea that elements are accessed sequentially, but independently of their ‘position’ in the collection; for example, labeling each element of a tree with its index in left-to-right order fits the pattern, but labeling each element with its depth does not. This traditional version of the pattern is sometimes called an EXTERNAL ITERATOR. 

An alternative INTERNAL ITERATOR approach assigns responsibility for managing the traversal to the collection instead of the client: the client needs only to provide an operation, which the collection applies to each of its elements. The latter approach is simpler to use, but less flexible; for example, it is not possible for the iteration to affect the order in which elements are accessed, nor to terminate the iteration early. This is the algorithm followed by the “Apply” function.

\subsection{Using a simple loop to iterate a container}

You can iterate any sequential container with a simple loop. You use the “Size” function to limit the loop. At each loop step you get the corresponding element with the “GetElement” function, present in this form in all containers.
\begin{verbatim}
// "Container" is a pointer to some container
for (size_t i=0; i<iContainer.Size(Container); i++) {
    someType *element = iContainer.GetElement(Container,i);
    // Use "element” here.
}
\end{verbatim}
For associative containers you retrieve first a StringCollection containing all keys using the \texttt{GetKeys} function, present in all associative containers. Then, you retrieve each element by looping through the string collection that you have obtained in a similar manner to the sequential containers. 

\subsection{Using the “Apply” function.}
The “Apply” function will iterate through all elements calling a given function for each one.1 Its prototype is:
\begin{verbatim}
void iContainer.Apply(Container, //pointer to some container
                      int(*Applyfn)(void *elem,void *arg),
                      void *arg);
\end{verbatim}
This function receives three arguments:
\begin{enumerate}
\item A pointer to the container.
\item A function pointer that should point to a function that receives two arguments: the element of the container, and an extra argument where it can receive (and write to) global information about the search.  This extra argument is 
\item The third one passed to the”Apply” function. Apply will pass this argument to the given function together with a pointer to the element retrieved from the container.
\end{enumerate}
\subsection{Using iterators}
Iterators are objects returned by each container that allow you to iterate (obviously) through all elements of a container.
You use iterators like this:
\begin{verbatim}
Iterator *it = iContainer.newIterator(Container *);
mytype *myobject;
for (myobject = it->GetFirst(it); 
     myobject!= NULL; 
     myobject = it->GetNext(it)) {
     // Work with "myobject” here
}
iContainer.DeleteIterator(it); // dispose the iterator object
\end{verbatim}
Iterators provide a container-independent way of iterating that will work with any container, both sequential or associative. In associative containers the specific sequence is implementation defined, and in sequential containers is the natural sequence.
Iterators always support always at least two methods:
\begin{verbatim}
void *iterator->GetFirst(iterator);
void *iterator->GetNext(iterator);
void *iterator->GetCurrent(iterator);
\end{verbatim}
All containers support the “newIterator”  and “deleteIterator” methods:
\begin{verbatim}
iterator *iContainer.newIterator(Container); 
int iContainer.deleteIterator(iterator);
\end{verbatim}
Iterators must be destroyed since they are allocated using the containers default allocator.

Sequential containers can support additional functions:
\begin{verbatim}
void *iterator->GetLast(iterator);
void *iterator->GetPrevious(iterator);
\end{verbatim}
This interface allows users to write fully general algorithms that will work with any container, independently of its internal structure. Obviously the performance can differ from container to container depending on usage.

All iterators will become invalid if the underlying container changes in any way,except through the iterator itself.\footnote{This is completely different to the C++ language. In C++ you may have an invalid iterator if you change the underlying container or not, depending on the operation and the specific container. This is a bad interface for the following reasons:
\begin{enumerate}
\item There are many rules to remember without underlying principles.
  You have to know the specifics of each container to know
  if the iterators are invalidated or not.

\item Any error leads directly to catastrophic consequences instead
   of being catched and signalled in an orderly fashion. Worst, errors
   do not produce always the same consequences, depending on what
   were the contents of the invalid memory you are using, on the
   memory allocation pattern, etc. In short, any error leads to
   very difficult maintenance problems.

\item Any modifications of the container type lead to a review of
   all code that uses that container since the rules change from
   container to container. Iterators that worked could be invalid
   now. This another source of errors.
\end{enumerate}
}
\section{Setting and retrieving the state: GetFlags and SetFlags}
Each container has a set of flags that can be read and written to change the container's behavior. The only flag that is defined by all containers
is the read-only flag. Implementations can extend this to offer different services like copy-on-write, or other applications. 
\section{Retrieving the number of elements stored: Size}
All containers support querying the number of elements stored. The prototype is:
\begin{verbatim}
    size_t iContainer.Size(Container *);
\end{verbatim}
There is no error return. If an error occurs the result is zero.
\section{Space used: Sizeof}
This computes the total size used by the container in bytes, including the header structure, the data stored, and any related storage, for instance any free lists, spare space used to grow an array, etc.
\begin{verbatim}
    size_t iContainer.Sizeof(Container *);
\end{verbatim}
If its argument is\Null, \texttt{Sizeof} returns the size of the container header. This can be used to allocate space for a container as a local variable for instance.
\section{Memory management}
All containers have a pointer to their allocator object. An allocator object is a simple interface that provides 4 functions:
\begin{enumerate}
\item malloc: A function that receives a \texttt{size\_t} and returns a \texttt{void *} pointing to a memory block of the requested size, or\Null if no more memory is available
\item realloc: A function that will resize a previously allocated block
\item free: A function that will release the memory allocated previously with malloc/realloc.
\item calloc: a function that will allocate n objects of m size and clear the memory block to zero before returning it. 
\end{enumerate}
At the start of the library runtime a default allocator object exists that uses the four functions of the standard C library. Other allocator objects can be used, and the user can change the global allocator at any time. Each container retrieves the default allocator object when created, and stores it in the container descriptor. Any further change to the default allocator will not affect existing containers that have already an allocator. When changing the allocator you should do that before creating the container.
 
Some containers are created without any heap management by default. You can introduce heap management by calling the “UseHeap” function, that will install a new heap in the container. Other containers are always created with a heap, and you should pass them an allocator object for object creation.

\subsection{Memory manager objects}
The library provides two memory manager objects:
\begin{enumerate}
\item The default memory manager, that receives the standard C library functions; malloc, free, realloc and calloc.
\item The debug memory manager that implements the same functions with added functionality designed to:
\begin{itemize}
\item
Catch the “double free” problem.
\item
Catch the overflow of a memory block
\item
Catch freeing a block that wasn't allocated
\end{itemize}
\end{enumerate}
\subsection{Pooled memory management}
The problem with the traditional C memory management is that it requires that the programmer cares about each piece of RAM that is allocated by the program and follows the lifetime of each piece to ensure that it gets returned to the system for reuse. In today's software world, this is just impractical.

A better strategy is to use a pool of memory where related memory allocations can b e done from a common pool. When the module finishes, all the allocated pool is freed just by destroying the whole pool. This is much easier to manage, and in many cases more efficient.
The proposed interface has the following functionalities:
\begin{enumerate}
\item Creation. The creation function receives a memory allocator to use for this pool.
\item Alloc. This function receives a pool and a size and returns a memory block, or\Null if there is no more memory.
\item Clear. This erases all objects allocated in the pool without returning the memory to the system.
\item Destroy. This releases all memory and destroys all objects.
\end{enumerate}
Note that there is no realloc, and that the “Clear” function is optional. Not all pools support it. The rationale for these decisions being that realloc would need to store the size of each block, what in a pool maintained by a single stack like pointer would be very expensive.
\subsection{Heap of same size objects}
Many containers are used to store sets of objects of the same size. The library provides a specialized heap management software for this application. It stores vectors of objects of the same size. The interface provided is as follows:
\begin{itemize}
\item Create. This function receives a memory manager object that will be used to allocate memory.
\item NewObject: returns an object to the application
\item AddToFreeList: Adds an object to the list of available objects
\item Size: Returns the size of the heap in bytes
\item DestroyFreeList: reclaims memory used by the free list
\item Destroy: Reclaims all memory used by the heap and the heap object
\end{itemize}

%--------------------------------------------------------------------------------------------------------------------------
%                                                   INTERFACES
%--------------------------------------------------------------------------------------------------------------------------
\chapter{The auxiliary interfaces}
\section{Memory management}
Several interfaces implement different memory allocation strategies. This should give flexibility to the implementations, allowing to use several memory allocation strategies within the same container.
\subsection{The traditional memory manager}
The heap memory manager for a collection of objects of the same size
the pool memory manager that manages a pool of different sized objects
The basic memory managers
The C language provides several functions to manage memory. The MemoryManager object presents an uniform interface for all memory managers that accept this interface.
\begin{verbatim}
typedef struct tagMemoryManager {
    void *(*malloc)(size_t);
    void  (*free)(void *);
    void *(*realloc)(void *,size_t);
    void *(*calloc)(size_t,size_t);
} ContainerMemoryManager;
extern ContainerMemoryManager * CurrentMemoryManager;
\end{verbatim}
At startup, the CurrentMemoryManager points to an object constructed with the functions of the C standard library. This is a required interface.
The user can change the object that “CurrentMemoryManager” points to to another object that should have the same interface.

The library can also include a debug version on top of the standard C functions, offering the same interface. Changing the CurrentMemoryManager to point to that object allows to switch to the debug version. The debug version offers:
\begin{itemize}
\item
Detection of free() of a memory block not allocated by malloc().
\item
Detection of  writing past the end of the block in some cases.
\item
Detection of freeing a memory block twice.
\end{itemize}
\begin{verbatim}
extern ContainerMemoryManager iDebugMalloc;
\end{verbatim}
This interface is optional. The sample implementation documents a possible implementation, \See{Malloc}.
\subsection{The Heap interface: iHeap}
Some containers can benefit from a cacheing memory manager that manages a stock of objects of the same size. This is not required and not all implementations may provide it. If they do, the interface is:
\begin{verbatim}
    int (*UseHeap)(Container *c);
\end{verbatim}
The standard interface for the heap is:\index{iHeap}
\begin{verbatim}
typedef struct tagHeapObject ContainerHeap;
typedef struct _HeapAllocatorInterface {
   ContainerHeap *(*Create)(size_t ElementSize,
                            ContainerMemoryManager *m);
   void *(*newObject)(ContainerHeap *heap);
   void (*AddToFreeList)(ContainerHeap *heap,void *element);
   void (*DestroyFreeList)(ContainerHeap *heap);
   void (*Destroy)(ContainerHeap *heap);
   size_t (*Sizeof)(ContainerHeap *heap);
} HeapInterface;
extern HeapInterface iHeap;
\end{verbatim}
\api{Create}
ContainerHeap *iHeap.Create(size_t elementSize, MemoryManager *m);
\end{verbatim}
\apidescription
Creates a new heap object that will use the given memory manager to allocate memory. All elements will have the given size. If the memory manager object pointer is\Null, the object pointed by CurrentMemoryManager will be used.
\returns a pointer to the new heap object or\Null, if an error occurred.
\apierrors
\doerror{BADARG} The element size is bigger than what the heap implementation can support..
\doerror{NOMEMORY} Not enough memory is available to complete the operation.
%--------------------------------------------------------------------------------------------------------------------------
\api{newObject}
   void *iHeap.newObject(ContainerHeap *heap);
\end{verbatim}
\apidescription{}
The heap returns a pointer to a new object or\Null if no more memory is left.
\apierrors
\doerror{NOMEMORY} Not enough memory is available to complete the operation.
\returns A pointer to an object or\Null if there is not enough memory to complete the operation.
%--------------------------------------------------------------------------------------------------------------------------
\api{AddToFreeList}
   size_t iHeap.AddToFreeList(ContainerHeap *heap,void *element);
\end{verbatim}
\apidescription{}
Adds the given object to the list of free objects, allowing for recycling of memory without new allocations. The element pointer can be\Null.
\apierrors{}
\doerror{BADARG} The heap pointer is\Null.
\returns The number of objects in the free list.
%--------------------------------------------------------------------------------------------------------------------------
\api{DestroyFreeList}
   void iHeap.DestroyFreeList(ContainerHeap *heap);
\end{verbatim}
\apidescription
Releases all memory used by the free list and resets the heap object to its state as it was when created.
\apierrors{}
\doerror{BADARG} The heap pointer is\Null.
%--------------------------------------------------------------------------------------------------------------------------
\api{Destroy}
    void iHeap.Destroy(ContainerHeap *heap);
\end{verbatim}
\apidescription
Destroys all memory used by the indicated heap and frees the heap object itself.
\apierrors
\doerror{BADARG} The heap pointer is\Null.
%--------------------------------------------------------------------------------------------------------------------------
\api{Sizeof}
    size_t iHeap.Sizeof(ContainerHeap *heap);
\end{verbatim}
\apidescription
Returns the number of bytes used by the given heap, including the size of the free list. If the argument \texttt{"heap"} is\Null, the result is the size of the heap header structure (i.e. \texttt{sizeof(ContainerHeap)}.

\section{Pooled memory interface: iPool}
\index{iPool}
Many containers could benefit from a memory pool. A memory pool groups all allocations done in a specific context and can be released in a single call. This allows the programmer to avoid having to manage each single piece of memory like the basic interface.
\begin{verbatim}
typedef struct Pool Pool;
typedef struct _tagPoolAllocatorInterface {
    Pool  *(*Create)(ContainerMemoryManager *m);
    void  *(*Alloc)(Pool *pool,size_t size);
    void  *(*Calloc)(Pool *pool,size_t size);
    void   (*Clear)(Pool *);
    void   (*Destroy)(Pool *);
} PoolAllocatorInterface;
\end{verbatim}
Note that there is no realloc function. Pooled memory is often implemented without storing the size of the block to cut overhead. Since a realloc function could be expensive, implementations are not required to provide it.
%--------------------------------------------------------------------------------------------------------------------------
\api{Create}
    Pool *iPool.Create(ContainerMemoryManager *m);
\end{verbatim}
\apidescription
Creates a new pool object that will use the given memory manager. If m is null, the object pointed by the CurrentMemoryManager will be used.
\apierrors
\doerror{NOMEMORY} Not enough memory to complete the operation.
\returns
A pointer to the new object or\Null if the operation couldn't be completed.
%--------------------------------------------------------------------------------------------------------------------------

\api{Alloc}
    void  *iPool.Alloc(Pool *pool,size_t size);
\end{verbatim}
\apidescription Allocates size bytes from the pool pool. If there isn't enough memory to resize the pool  the result is\Null.
\apierrors
\doerror{NOMEMORY} Not enough memory to complete the operation.
\returns
A pointer to the allocated memory or\Null if error.
%--------------------------------------------------------------------------------------------------------------------------

\api{Calloc}
    void  *iPool.Calloc(Pool *pool,size_t n,size_t size);
\end{verbatim}
\apidescription
Allocates n objects of size “size” in a single block. All memory is initialized to zero. If there is no memory left it returns\Null;
\apierrors
\doerror{NOMEMORY} Not enough memory to complete the operation.
\returns
A pointer to the allocated memory or\Null if error.
%--------------------------------------------------------------------------------------------------------------------------

\api{Clear}
    void iPool.Clear(Pool *);
\end{verbatim}
\apidescription
Reclaims all memory used by the pool and leaves the object as it was when created.
\apierrors
\doerror{BADARG} The pool pointer is\Null.
%--------------------------------------------------------------------------------------------------------------------------

\api{Destroy}
    void   iPool.Destroy(Pool *);
\end{verbatim}
\apidescription
Reclaims all memory used by the pool and destroys the pool object itself.
\apierrors
\doerror{BADARG} The pool pointer is\Null.
%--------------------------------------------------------------------------------------------------------------------------


\section{Error handling Interface: iError}
\index{iError}
The “iError” interface provides a default strategy for handling errors. The “RaiseError” function will be used as the default error function within the creation function for all containers that support a per container instance error function.
\begin{verbatim}
typedef (*ErrorFunction)(const char *,int);
typedef struct {
  void        (*RaiseError)(const char *fname,int code);
  void        (*EmptyErrorFunction)(const char *fname,int code);
  const char *(*StrError)(int errorCode);
  ErrorFunction (*SetErrorFunction)(ErrorFunction);
} ErrorInterface;
\end{verbatim}
%--------------------------------------------------------------------------------------------------------------------------

\api{RaiseError}
 void      iError.RaiseError(const char *fname,int errcode);
\end{verbatim}
\apidescription
The parameter “fname” should be the name of the function where the error occurs. The “errcode” parameter is a negative error code. The actual value of the code is implementation defined.
The behavior of the default error function is implementation specific. In the sample code this function will just print the error message in the standard error stream. Other implementations could end the program, or do nothing.
\returns No return value
%--------------------------------------------------------------------------------------------------------------------------

\api{EmptyErrorFunction}
 void      iError.EmptyErrorFunction(const char *fname,int errcode);
\end{verbatim}
\apidescription
This function can be used to ignore all errors within the library. It does nothing.
%--------------------------------------------------------------------------------------------------------------------------

\api{StrError}
  const char *iError.StrError(int errorCode);
\end{verbatim}
\apidescription
Converts the given error code in a character string. If the error code doesn't correspond to any error defined by the implementation a charracter string with an implementation defined value is returned.
%--------------------------------------------------------------------------------------------------------------------------

\api{SetErrorFunction}
  ErrorFunction iError.SetErrorFunction(ErrorFunction);
\end{verbatim}
\apidescription
Changes the value of the default error function. If its argument is\Null, nothing is done, and the call is interpreted as a query of the current value.
\returns
The old value of the default error function.
%--------------------------------------------------------------------------------------------------------------------------

\section{The iterator interface}
The iterator object exposes at least the functions “GetFirst”, for initializing the loop, and “GetNext”, for getting the next element in the sequence. The functions “newIterator” and “deleteIterator” are specific to each container interface even if they all have the same syntax.
\subsection{The interface}
\begin{verbatim}
typedef struct _Iterator {
    void *(*GetNext)(Iterator *);
    void *(*GetPrevious)(Iterator *);
    void *(*GetFirst)(Iterator *);
    void *(*GetCurrent)(Iterator *);
    void *(*GetLast)(Iterator *);
} Iterator;
\end{verbatim}
%--------------------------------------------------------------------------------------------------------------------------
\api{GetCurrent}
    void *(*GetCurrent)(Iterator *);
\end{verbatim}
\apidescription Returns the element at the cursor position.
\apierrors
\doerror{BADARG} The iterator pointer is\Null.
\returns
A pointer to the first element or\Null, if the container is empty or an error occurs. If the container is read-only, a pointer to a copy of the element is returned. This pointer is valid only until the next iterator function is called.

\api{GetFirst}
    void *(*GetFirst)(Iterator *);
\end{verbatim}
\apidescription
This function initializes the given iterator to the first element in the container. For sequential operators this is the element with index zero. In associative operators which element is the first is implementation defined and can change if elements are added or removed from the container.
\apierrors
\doerror{BADARG} The iterator pointer is\Null.
\returns
A pointer to the first element or\Null, if the container is empty or an error occurs. If the container is read-only, a pointer to a copy of the element is returned. This pointer is valid only until the next iterator function is called.
\example
Iterator *myIterator;
List *myList;
myType *obj; // "myList" stores objects of type "myType"
myIterator = iList.newIterator(myList); // Request iterator
for (obj = myIterator->GetFirst(myIterator); 
     obj != NULL; 
     obj = myIterator->GetNext(myIterator)) {
     //Use obj here
}
iList.deleteIterator(myIterator); // Reclaim memory
\end{verbatim}
%--------------------------------------------------------------------------------------------------------------------------

\api{GetNext}
    void *(*GetNext)(Iterator *);
\end{verbatim}
\apidescription
Positions de cursor at the next element and returns a pointer to its contents. If the container is read-only, a pointer to a copy of the object is returned. This pointer is valid only until the next iterator function is called.
\apierrors
\doerror{BADARG} The iterator pointer is\Null.
\doerror{OBJECT\_CHANGED} The container has been modified and the iterator is invalid. Further calls always return\Null.
\returns
A pointer to the next element or\Null, if the cursor reaches the last element. If the container is read-only, a pointer to a copy of the element is returned, valid until the next element is retrieved
%--------------------------------------------------------------------------------------------------------------------------
\api{GetPrevious}
    void *(*GetPrevious)(Iterator *);
\end{verbatim}
\apidescription
Positions de cursor at the next element and returns a pointer to its contents.
This function is meaningful only in sequential containers. Its existence in associative containers is implementation defined. Even in sequential containers, it can be very expensive to find a previous element, for instance in single linked lists. In those cases it can always return\Null.
\apierrors
\doerror{BADARG} The iterator pointer is\Null.
\doerror{OBJECT\_CHANGED} The container has been modified and the iterator is invalid. Further calls always return\Null.
\returns
A pointer to the next element or\Null, if the cursor reached the  element already. If the container is read-only, a pointer to a copy of the element is returned.
\example
Iterator *myIterator;
List *myList;
myType *obj; // "myList" stores objects of type "myType"
myIterator = iList.newIterator(myList); // Request iterator
for (obj = myIterator->GetLast(myIterator); 
     obj != NULL; 
     obj = myIterator->GetPrevious(myIterator)) {
     //Use obj here
}
iList.deleteIterator(myIterator); // Reclaim memory
\end{verbatim}
\api{GetCurrent}
   void *GetCurrent(Iterator *);
\end{verbatim}
\apidescription
Returns a pointer to the current element's data without moving the cursor.
%--------------------------------------------------------------------------------------------------------------------------
\api{GetLast}
    void *(*GetLast)(Iterator *);
\end{verbatim}
\apidescription
Positions the cursor at the last element and returns a pointer to it. Returns\Null if the container is empty.  If the container is read-only, a pointer to a copy of the element is returned.

This function is meaningful only in sequential containers. Its existence in associative containers is implementation defined. Even in sequential containers, it can be very expensive to find the last element, for instance in single linked lists. In those cases it can always return\Null.
\apierrors
\doerror{BADARG} The iterator pointer is\Null.
\doerror{OBJECT\_CHANGED} The container has been modified and the iterator is invalid. Further calls always return\Null.
%--------------------------------------------------------------------------------------------------------------------------
%                                                   LISTS
%--------------------------------------------------------------------------------------------------------------------------
\chapter{The containers}
\section{The List interfaces: iList, iDlist}
The list container appears in two flavors: 
\begin{itemize}
\item
single linked lists: the iList type
\item
double linked lists the iDlist type
\end{itemize}
The space overhead of single linked lists is smaller at the expense of more difficult access to the elements. It is up to the application programmer to decide which container fits best in his/her application.

The interfaces of both containers are very similar. Double linked lists support all functions in single linked ones, and add a few more. To avoid unnecessary repetition we document here all the single linked list interface, then only the functions that the Dlist interface adds to it.
\index{iList}\index{lists!single linked}
\begin{verbatim}
typedef struct _List List;
typedef struct {
    int (*Add)(List *L,void *newval);
    List *(*Append)(List *l1,List *l2);
    void (*Apply)(List *L,int(Applyfn)(void *elem,void *arg),void *arg);
    int (*Clear)(List *L); 
    int (*Contains)(List *L,void *element);
    List *(*Create)(size_t element_size);
    List *(*CreateWithAllocator)(size_t elementsize,
                       ContainerMemoryManager *allocator);
    List *(*Copy)(List *L);
    int (*deleteIterator)(Iterator *);
    int (*Erase)(List *L,void *);
    int (*EraseAt)(List *L,size_t idx);
    int (*EraseRange)(List *L,size_t start,size_t end);    
    int (*Equal)(List *l1,List *l2);
    	ContainerMemoryManager *(*GetAllocator)(List *list);
    void *(*GetElement)(List *L,int idx);
    size_t (*GetElementSize)(List *l);
    unsigned (*GetFlags)(List *L);
    List *(*GetRange)(List *l,size_t start,size_t end);
    int (*Finalize)(List *L);
    int (*IndexOf)(List *L,void *SearchedElement,size_t *result);
    List *(*Init)(List *aList,size_t element_size);
    List *(*InitWithAllocator)(List *aList,size_t element_size,
                               ContainerMemoryManager *allocator);
    int (*Insert)(List *L,void *);
    int (*InsertAt)(List *L,size_t idx,void *newVal);
    int (*InsertIn)(List *Destination, size_t position, List *source);
    List *(*Load)(FILE *stream, ReadFunction loadFn,void *arg);
    Iterator *(*newIterator)(List *L);
    int (*PushFront)(List *L,void *str);
    int (*PopFront)(List *L,void *result);
    int (*ReplaceAt)(List *L,size_t idx,void *newVal);
    List *(*Reverse)(List *l);
    int (*Save)(List *L,FILE *stream, SaveFunction saveFn,void *arg);
    void *(*Seek)(Iterator *it,size_t pos);
    int (*Sort)(List *l);
    int (*Size)(List *L); 
    size_t (*Sizeof)(List *l);
    CompareFunction (*SetCompareFunction)(List *l,CompareFunction fn);
    ErrorFunction (*SetErrorFunction)(List *L,ErrorFunction); 
    unsigned (*SetFlags)(List *L,unsigned flags);
    int (*UseHeap)(List *L, ContainerMemoryManager *m);
} ListInterface;

extern ListInterface iList;
\end{verbatim}
\subsection{General remarks}
Lists are containers that store each element in a sequence, unidirectionally (single linked lists) or bidirectionally (double linked lists).
The advantage of linked lists is their flexibility. You can easily and with a very low cost remove or add elements by manipulating the links between the elements. Single linked lists have less overhead than their double linked counterparts (one pointer less in each node), but they tend to use a lot of computer power when inserting elements near the end of the list: you have to follow all links from the beginning until you find the right one.

The list nodes themselves do not move around, only their links are changed. This can be important if you maintain pointers to those elements. Obviously, if you delete a node, its contents (that do not move) could be recycled to contain something else than what you expect.

The “iList” interface consists (as all other interfaces) of a table of function pointers. The interface describes the behavior of the List container.

The stack operations push and pop are provided with PushFront and PopFront because they have a very low cost, insertion at the start of a single linked list is very fast. PushBack is the equivalent of the “Add” operation, but PopBack would have a very high cost since it would need going through all the list. 

The list container features in some implementations a per list error function.  This is the function that will be called for any errors, except in  cases where no list object exists: the creation function, or the error of getting a\Null pointer instead of a list pointer. In those cases the general iError interface is used, and iError.RaiseError is called. The default value of the list error function is the function iError.RaiseError at the moment the list is created.

Other implementations of this interface may specialize list for a certain category of uses: lists of a few elements would try to reduce overhead by eliminating a per list error function and replace it with the standard error function in iError, for instance, eliminating their fields in the header. If the read-only flag support is dropped, the whole “Flags” field can be eliminated. In such an implementation, the SetFlags primitive would always return an error code.

The List container supports the following state flags:
\begin{verbatim}
#define CONTAINER_LIST_READONLY    1
\end{verbatim}
If this flag is set, no modifications to the container are allowed, and the Clear and Finalize functions will not work. Only copies of the data are handed out, no direct pointers to the data are available.
%--------------------------------------------------------------------------------------------------------------------------
\api{Add}
    int (*Add)(List *l,void *data);
\end{verbatim}
\apidescription
Adds the given element to the container. It is assumed that “data” points to a contiguous memory area of at least ElementSize bytes. Returns a value greater than zero if the addition of the element to the list completed successfully, a negative error code otherwise. The error codes returned can be:
\doerror{BADARG} The list or the data pointers are\Null.
\doerror{READONLY} The list is read-only. No modifications allowed.
\doerror{NOMEMORY} Not enough memory to complete the operation.
\returns
Returns the number of elements stored if it is less than \textsc{INT\_MAX}, or \textsc{INT\_MAX} if there are more elements stored than the value of \textsc{INT\_MAX}. If the return value is negative, an error occurred.
\example
/* This example shows how to: 
(1) Create a linked list of "double" data
(2) Fill it using the "Add" function
(3) Print it using the GetElement function */
#include <containers.h>
static void PrintList(List *AL)
{
    size_t i;
    for (i=0; i<iList.Size(AL);i++) {
        printf("%g ",*(double *)iList.GetElement(AL,i));
    }
    printf("\n");
}
static void FillList(List * AL,size_t siz)
{
    size_t i;

    for (i=0; i<siz;i++) {
        double d = i;
        iList.Add(AL,&d);
    }
}

int main(void)
{
    List *AL = iList.Create(sizeof(double));
    FillList(AL,10);
    PrintList(AL);
    return 0;
}
OUTPUT:
0 1 2 3 4 5 6 7 8 9
\end{verbatim}
%--------------------------------------------------------------------------------------------------------------------------
\api{Append}
    int (*Append)(List *list1,List *list2);
\end{verbatim}
\apidescription
Appends the contents of list2 to list1 and destroys list2.
\apierrors
\doerror{BADARG} Either list1 or list2 are\Null.
\doerror{READONLY} One or both lists are read only.
\returns
A positive value if the operation succeeded, or a negative error code otherwise.
\example
#include <containers.h>
static void PrintList(List *AL)
{
    size_t i;
    for (i=0; i<iList.Size(AL);i++) {
        printf("%g ",*(double *)iList.GetElement(AL,i));
    }
    printf("\n");
}
static void FillList(List * AL,size_t siz)
{
    size_t i;

    for (i=0; i<siz;i++) { double d = i; iList.Add(AL,&d);}
}

int main(void)
{
    List *L1 = iList.Create(sizeof(double));
    List *L2 = iList.Create(sizeof(double));
    FillList(L1,10);
    FillList(L2,10);
    iList.Append(L1,L2);
    PrintList(L1);
    return 0;
}
OUTPUT:
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
\end{verbatim}
%--------------------------------------------------------------------------------------------------------------------------
\api{Apply}
    int (*Apply)(List l,int (Applyfn)(void *,void *),void *arg);
\end{verbatim}
\apidescription
Will call the given function for each element of the list. The first argument of the callback function receives an element of the list. The second argument of the callback is the arg argument that the Apply function receives and passes to  the callback. This way some context can be passed to the callback, and from one element to the next.
Note that the result of the callback is not used. This allows all kinds of result types to be accepted after a suitable cast.
If the list is read-only, a copy of the element will be passed to the callback function.
\apierrors
\doerror{BADARG} Either list or Applyfn are\Null.
\doerror{NOMEMORY}: The list is read-only and there is no more memory to allocate the buffer to copy each element.
\notes
The list container of C++ has no direct equivalent, but in the algorithm part of the STL there is a “for\_each” construct, that does essentially the same. Java and C\# offer a similar “ForEach” functionality.
 
\example
#include <containers.h>
static int Callback(void *pElement,void *pResult)
{
    double *p = pElement;
    double *result = pResult;
    *result += *p;
    return 1;
}
    
void main(void) 
{
    double sum = 0;
    List *list = iList.Create(sizeof(double));
    double d = 2;
    iList.Add(list,&d);
    d = 3;
    iList.Add(list,&d);
    iList.Apply(list,Callback,&sum);
    // Here sum should be 5.
    printf("%g\n",sum);
}
\end{verbatim}
The above example shows a function callback as used by "Apply". It receives two pointers, one to the current element and another to an extra argument that in this case contains a pointer to the sum. For each call to the callback, the function adds the contents of the element to the sum.

The main function creates a list, adds two elements with the values 2 and 3, and then calls "Apply" to get their sum using the callback.
%--------------------------------------------------------------------------------------------------------------------------
\api{Clear}
    int (*Clear)(List *l);
\end{verbatim}
\apidescription
Erases all stored data and releases the memory associated with it. The list header will not be destroyed, and its contents will be the same as when the list was initially created. It is an error to use this function when there are still active iterators for the container.
\apierrors
\doerror{BADARG} The list pointer is\Null.
\doerror{READONLY} The list is read only.
\returns
The result is greater than zero if successful, or an error code if an error occurs. 
\notes Java, C++ and C\# have a similar “Clear” functionality. 
\example
    List *l;
    int m = iList.Clear(l);
\end{verbatim}
%--------------------------------------------------------------------------------------------------------------------------
\api{Contains}
    int (*Contains)(List *list,void *data);
\end{verbatim}
\apidescription
Returns one if the given data is stored in the list, zero otherwise. The “data” argument is supposed to point to an element at least ElementSize bytes. The list's comparison function is used for determining if two elements are equal. This comparison function defaults to memcmp.
\apierrors
\doerror{BADARG} Either list or data are\Null.
\notes
C++ has std::find that does essentially the same . Java and C\# have a “Contains” method.
\example
    List *list;
    int r = iList.Contains(list,&data);
\end{verbatim}

%--------------------------------------------------------------------------------------------------------------------------
\api{Copy}
    List *(*Copy)(List *L);
\end{verbatim}
\apidescription
A shallow copy of the given list is performed. Only ElementSize bytes will be copied for each element. If the element contains pointers, only the pointers are copied, not the objects they point to. The new memory will be allocated using the given list's allocator.
\apierrors
\doerror{NOMEMORY} There is not enough memory to complete the operation.
\doerror{BADARG} The given list pointer is\Null.
\notes
C++ has no direct equivalent but the assignment operator should work, Java and C\# support a copy method.
\example
    List *newList,*OldList;
    newList = iList.Copy(OldList);
    if (newList == NULL) { /* Error handling */ }
\end{verbatim}

%--------------------------------------------------------------------------------------------------------------------------
\api{CopyElement}
    int (*CopyElement)(List *list,size_t idx,void *outBuffer);
\end{verbatim}
\apidescription
Copies the element data at the given position into the given buffer, assuming that at least ElementSize bytes of storage are available at the position pointed by the output buffer. The main usage of this function is to access data in a read only container for later modification.
\apierrors
\doerror{BADARG} The given list pointer or the output buffer are\Null.
\doerror{INDEX} The given position is out of bounds.

\returns
A positive value if the operation succeeded, or a negative error code if it failed.

\notes
Neither C\# nor Java provide this functionality because the treatment of pointers in those languages makes the need for such a construct unnecessary.

\example
    List *list; double d;
    if (iList.CopyElement(list,3,&d) > 0)
        printf("The value at position 3 is %g\n”,d);
\end{verbatim}

%--------------------------------------------------------------------------------------------------------------------------
\api{Create}
    List *(*Create)(size_t element_size);
\end{verbatim}
\apidescription
The creation function returns an empty List container, initialized with all the default values.
The current memory manager is used to allocate the space needed for the List header. The list is supposed to contain elements of the same size. If the elements you want to store are of different size, use a pointer to them, and create the list with sizeof(void *) as the size parameter.
\returns
A pointer to a newly created List or\Null if an error occurs.
\apierrors
\doerror{NOMEMORY} There is not enough memory to complete the operation.
\doerror{BADARG} The given element size is zero or greater than what the implementation allows for maximum object size.

Errors provoke the call of the current default error function of the library since this is the creation function and there isn't a container specific error function yet.
\example
    List *ListOfDoubles = iList.Create(sizeof(double));
\end{verbatim}
\api{CreateWithAllocator}
List *(*CreateWithAllocator)(size_t elem_size,
                             ContainerMemoryManager *allocator);
\end{verbatim}
\apidescription
The creation function returns an empty List container, initialized with all the default values.
The given memory manager is used to allocate the space needed for the List header. The list is supposed to contain elements of the same size. If the elements you want to store are of different size, use a pointer to them, and create the list with sizeof(void *) as the size parameter.
\returns
A pointer to a newly created List or\Null if an error occurs.
\apierrors
\doerror{NOMEMORY} There is not enough memory to complete the operation.
\doerror{BADARG} The given element size is zero or greater than what the implementation allows for maximum object size, or the given allocator pointer is\Null.

Errors provoke the call of the current default error function of the library since this is the creation function and there isn't a container specific error function yet.
\example
    ContainerMemoryManager *myAllocator;
    List *ListOfDoubles = 
          iList.CreateWithAllocator(sizeof(double),myAllocator);
\end{verbatim}
%--------------------------------------------------------------------------------------------------------------------------
\api{deleteIterator}
    int deleteIterator(Iterator *it);
\end{verbatim}
\apidescription
Reclaims the memory used by the given iterator object
\apierrors
\doerror{BADARG} The iterator pointer is\Null.
\returns A positive value if successful or a negative error code.

%--------------------------------------------------------------------------------------------------------------------------
\api{Equal}
    int (*Equal)(List *list1List *list2);
\end{verbatim}
\apidescription
Compares the given lists using the list comparison function of either list1 or list2 that must compare equal. If the list differ in their length, flags, or any other characteristic they compare unequal. If any of their elements differ, they compare unequal.
If both list1 and list2 are\Null they compare equal. If both list1 and list2 are empty they compare equal.
\apierrors
None
\returns
The result is one if the lists are equal, zero otherwise.
\api{Erase}
    int (*Erase)(List *list,void *data);
\end{verbatim}
\apidescription
Removes from the list the element that matches the given data, that is assumed to be a pointer to an element.
\returns
A negative error code if an error occurred, or a positive value that indicates that a match was found and the element was removed. If the element is not in the list the result is CONTAINER\_ERROR\_NOTFOUND.
\apierrors
\doerror{BADARG} One or both arguments are\Null.
\example
    double d = 2.3;
    List *list;
    int r = iList.Erase(list,&d);
    if (r > 0)
        printf("2.3 erased\n”);
    else if (r == CONTAINER_ERROR_NOTFOUND)
        printf("No element with value 2.3 present\n”);
    else
        printf("2.3 not erased. Error is \%s\n”,iError.StrError(r));
\end{verbatim}

\api{EraseAt}
    int (*EraseAt)(List *list,size_t idx);
\end{verbatim}
\apidescription
Removes from the list the element at the given position.
\returns
A negative error code if an error occurred or a positive value that indicates that the element was removed.

\apierrors
\doerror{BADARG} The given list pointer is\Null.
\doerror{INDEX} The given position is out of bounds.

\example
    List *list;
    int r = iList.EraseAt(list,2);
    if (r > 0)
        printf("Element at position 2 erased\n”);
    else
        printf("Error code %d\n”,r);
\end{verbatim}
\api{EraseRange}
  int (*EraseRange)(List *L,size_t start,size_t end);
\end{verbatim}
\apidescription
Removes from the list the given range, starting with the \texttt{start} index, until the element before the \texttt{end} index. If \texttt{end}
is greater than the length of the list, it will be 'rounded' to the length of the list.
\apierrors
\doerror{BADARG} The given list pointer is\Null.
\returns
A positive number indicates success, zero means nothing was erased, and a negative number an error.
\example
#include <containers.h>
static void print_list(List *li)
{
        int i;
        for (i=0; i<iList.Size(li); i++)
                printf(" %d",*(int *)iList.GetElement(li,i));
        printf("\n");
}
int main(void)
{
    List *li = iList.Create(sizeof(int));
    int i;
    for (i=0; i<10;i++) {
        iList.Add(li,&i);
    }
    print_list(li);
    iList.EraseRange(li,3,8);
    print_list(li);
}
OUTPUT:
 0 1 2 3 4 5 6 7 8 9
 0 1 2 8 9
\end{verbatim}
\api{Finalize}
    int (*Finalize)(List *list);
\end{verbatim}
\apidescription
Reclaims all memory used by the list, including the list header object itself.
\apierrors
\doerror{BADARG} The given list pointer is\Null.
\doerror{READONLY} The list is read-only. No modifications allowed.
\returns
A positive value means the operation completed. A negative error code indicates failure.
\example
    List *list;
    int r = iList.Finalize(list);
    if (r < 0) { /* error handling */ }
\end{verbatim}
\api{GetAllocator}
ContainerMemoryManager *(*GetAllocator)(List *l);
\end{verbatim}
\apidescription
Returns the list's allocator object. If the list pointer is\Null it returns\Null.
\api{GetElementSize}
    size_t (*GetElementSize)(List *l);
\end{verbatim}
\apidescription
Retrieves the size of the elements stored in the given list. Note that this value can be different than the value given to the creation function because of alignment requirements.
\apierrors
\doerror{BADARG} The given list pointer is\Null.

\returns
The element size.

\example
    List *l;
    size_t siz = iList.GetElementSize(l);
\end{verbatim}

\api{GetElement}
    void *(*GetElement)(List *list,size_t idx);
\end{verbatim}
\apidescription
Returns a read only pointer to the element at the given index, or\Null if the operation failed.  This function will return\Null if the list is read only.
 
Use the CopyElement function to get a read/write copy of an element of the list.

\apierrors
\doerror{BADARG} The given list pointer is\Null.
\doerror{INDEX} The given position is out of bounds.
\doerror{READONLY} The list is read only.
\example
    List *list;
    double d = *(double *)iList.GetElement(list,3);
\end{verbatim}

\api{GetFlags / SetFlags}
    unsigned (*GetFlags)(List *l);
    unsigned (*SetFlags)(List *l,unsigned newFlags);
\end{verbatim}
\apidescription
GetFlags returns the state of the container flags, SetFlags sets the flags to a new value and returns the old value.
\apierrors
\doerror{BADARG} The given list pointer is\Null.
\returns
The flags or zero if there was an error.

\api{GetRange}
    List *(*GetRange)(List *list,size_t start,size_t end);
\end{verbatim}
\apidescription
Selects a series of consecutive elements starting at position start and ending at position end.  Both the elements at start and end are included in the result.
If start is greater than end start and end are interchanged. If end is bigger than the number of elements in list, only elements up to the number of elements will be used. If both start and end are out of range an error is issued and\Null is returned.
The selected elements are copied into a new list. The original list remains unchanged.
\apierrors
\doerror{BADARG} The given list pointer is\Null
\doerror{INDEX} Both start and end are out of range.
\returns
A pointer to a new list containing the selected elements or\Null if an error occurs.
\example
    List *list;
    List *range = iList.GetRange(list,2,5);
    if (range == NULL) { /* Error handling */ }
\end{verbatim}

\api{IndexOf}
int (*IndexOf)(List *l,void *ElementToFind,void *args,size_t *result);
\end{verbatim}
\apidescription
Searches for an element in the list. If found its zero based index is returned in the passed pointer "result". 

Otherwise the result of the search is  CONTAINER\_ERROR\_NOTFOUND and the passed pointer will remain unmodified. The “args” argument will be passed to the comparison function that is called by IndexOf.
\apierrors
\doerror{BADARG} The given list pointer or element are\Null.
\returns
A positive value if element is found or a negative value if not found or an error occurs.
\example
    List *list;
    double data;
    size_t idx;
    int r = iList.IndexOf(list,&data,&idx);
    if (r == CONTAINER_ERROR_NOTFOUND)
        printf("Not found\n”);
    else if (r < 0)
        printf("Error\n");
    else printf("Found at position %ld\n",idx);
\end{verbatim}
\api{Init}
List *(*Init)(List *aList,size_t element_size);
\end{verbatim}
\apidescription
Initializes the memory pointed by the \texttt{aList} argument. The new list will use the allocator pointed by the current memory allocator.
It is assumed that the memory pointed by \texttt{aList} contains at least the size of the header object. This size can be obtained by calling the Sizeof function with a\Null argument.
\apierrors
\doerror{BADARG} The given list pointer is\Null.
\example
// This example uses C99
void Example(void)
{
    char aList[iList.Sizeof(NULL)];
    List *list = iList.Init((List *)aList);
}
\end{verbatim}
\api{InitWithAllocator}
    List *(*InitWithAllocator)(List *aList,
                               size_t element_size,
                               ContainerMemoryManager *allocator);
\end{verbatim}
\apidescription
Initializes the memory pointed by the \texttt{aList} argument. The new list will use the given allocator.
It is assumed that the memory pointed by \texttt{aList} contains at least the size of the header object. This size can be obtained by calling the Sizeof function with a\Null argument.
\apierrors
\doerror{BADARG} The given list pointer is\Null.

\api{InsertAt}
    int (*InsertAt)(List *L,size_t idx,void *newData);
\end{verbatim}
\apidescription
Inserts the new element. The new element will have the given index, that can go from zero to the list count inclusive, i.e. one more than the number of elements in the list. In single linked lists the cost for this operation is proportional to idx.
\apierrors
\doerror{BADARG} The given list pointer or the element given are\Null.
\doerror{READONLY} The list is read only.
\doerror{INDEX} The given position is out of bounds.
\doerror{NOMEMORY} There is not enough memory to complete the operation.

\returns
A positive value if the operation succeeded, or a negative error code if the operation failed.
\example
    double d;
    List *list;
    int r = iList.InsertAt(list,2,&d);
    if (r < 0) { /* Error handling */ }
\end{verbatim}

\api{InsertIn}
    int (*InsertIn)(List *Destination, size_t position, List *source);
\end{verbatim}
\apidescription
Inserts the list given in  its third argument at the given position in the list pointed to by its first argument. The data is copied, and the source argument is not modified in any way. Both lists must have elements of the same type. The library only tests the size of each one.
\apierrors
\doerror{BADARG} The source or the destination lists are\Null.
\doerror{READONLY} The destination list is read only.
\doerror{INDEX} The given position is out of bounds.
\doerror{NOMEMORY} There is not enough memory to complete the operation.
\doerror{INCOMPATIBLE} The lists store elements of different size.
\returns
A positive value if the operation succeeded, or a negative error code if the operation failed.
\example
#include <containers.h>
/* Prints the contents of a list */
static void PrintList(List *AL)
{
    size_t i;
    printf("Count %ld\n",(long)iList.Size(AL));
    for (i=0; i<iList.Size(AL);i++) {
        printf("%g ",*(double *)iList.GetElement(AL,i));
    }
    printf("\n");
}
/* Fills a list with 10 numbers. The 10 is hardwired... */
static void FillList(List * AL,int start)
{
    size_t i;

    for (i=0; i<10;i++) {
        double d = i+start;
        iList.Add(AL,&d);
    }
}
/* Creates two lists: one with the numbers from 0 to 9, another 
   with numbers 100 to 109, then inserts the second into the 
   first at position 5 */
int main(void)
{
    List *AL = iList.Create(sizeof(double));
    List *AL1 =iList.Create(sizeof(double));
    FillList(AL,0);
    FillList(AL1,100);
    iList.InsertIn(AL,5,AL1);
    PrintList(AL);
    return 0;
}
OUTPUT:
Count 20
0 1 2 3 4 100 101 102 103 104 105 106 107 108 109 5 6 7 8 9
\end{verbatim}
\api{Load}
    List *(*Load)(FILE *stream,ReadFunction readFn,void *arg);
\end{verbatim}
\apidescription
Reads a list previously saved with the Save function from the stream pointed to by stream. If readFn is not\Null, it will be used to read each element. The “arg” argument will be passed to the read function. If the read function is\Null, this argument is ignored and a default read function is used.
\apierrors
\doerror{BADARG} The given stream pointer is\Null.
\doerror{NOMEMORY} There is not enough memory to complete the operation.

\returns
A new list or\Null if the operation could not be completed. Note that the function pointers in the list are NOT saved, nor any special allocator that was in the original list. Those values will be the values by default. To rebuild the original state the user should replace the pointers again with the new list.

\api{newIterator}
    Iterator *(*newIterator)(List *list);
\end{verbatim}
\apidescription
Allocates and initializes a new iterator object to iterate this list.
\apierrors
If no more memory is available it returns\Null.
\returns
A pointer to a new iterator or\Null if there is no more memory left.
\example
    List *list;
    Iterator *it = iList.newIterator(list);
    double *d;
    for (d=it->GetFirst(it); d != NULL; d = it->GetNext(it)) {
        double val = *d;
        // Work with the value here
    }
    iList.deleteIterator(it);
\end{verbatim}

\api{PopFront}
int (*PopFront)(List *L,void *result);
\end{verbatim}
\apidescription
Pops the element at position zero copying it to the result pointer. If the “result” pointer is\Null, the first element is removed without any copying. The library supposes that result points to at least ElementSize bytes of contiguous storage. 
\apierrors
\doerror{BADARG} The list or the result pointer are\Null.
\doerror{READONLY} The list is read only.
\returns
A positive value if an element was popped, zero if the list was empty, or a negative error code if an error occurred.
\example
    double d;
    int r = iList.PopFront(L,&d);
    if (r==0)
        printf("List empty\n”);
    else if (r < 0) {
        printf("Error %d\n”,r);
    else    printf("OK, popped value %g\n”,d);
\end{verbatim}

\api{PushFront}
    int (*PushFront)(List *L,void *element);
\end{verbatim}
\apidescription
Inserts the given element at position zero. 
\apierrors
\doerror{BADARG} The list or the element pointer are\Null.
\doerror{READONLY} The list is read only.
\doerror{NOMEMORY} There is not enough memory to complete the operation.

\returns
A positive value if the operation completed, or a negative error code otherwise.
\example
    double d = 2.3;
    if (iList.PushFront(list,&d) < 0)
        printf("Error\n”);
\end{verbatim}

\api{ReplaceAt}
    int (*ReplaceAt)(List *list,size_t idx,void *newData);
\end{verbatim}
\apidescription
Replaces the list element at position idx with the new data starting at the position pointed to by “newData” and extending ElementSize bytes.
\apierrors
\doerror{BADARG} The list or the new element pointer are\Null.
\doerror{READONLY} The list is read only.
\doerror{INDEX} The given position is out of bounds.
\returns
A negative error code if an error occurs, or a positive value if the operation succeeded.
\example
    List *list;
    double d = 6.7;
    int r = iList.ReplaceAt(list,2,&d);
    if (r < 0) { /* Error handling */ }
\end{verbatim}

\api{Reverse}
    int (*Reverse)(List *list);
\end{verbatim}
\apidescription
Reverses the order of the given list: the head becomes the tail and the tail becomes the head. The original order is lost.
\apierrors
\doerror{BADARG} The list pointer is\Null.
\doerror{READONLY} The list is read only.
\returns
A negative error code if an error occurs, or a positive value if the operation succeeded.
\example
#include <containers.h>
static void print_list(List *li)
{
        int i;
        for (i=0; i<iList.Size(li); i++)
                printf(" %d",*(int *)iList.GetElement(li,i));
        printf("\n");
}
int main(void)
{
    List *li = iList.Create(sizeof(int));
    int i;
    for (i=0; i<10;i++) {
        iList.Add(li,&i);
    }
    print_list(li);
    iList.Reverse(li);
    print_list(li);
}
OUTPUT
 0 1 2 3 4 5 6 7 8 9
 9 8 7 6 5 4 3 2 1 0
\end{verbatim}
\api{Seek}
void *(*Seek)(Iterator *it,size_t pos);
\end{verbatim}
\apidescription
Positions the given iterator at the indicated position and then returns a pointer to the element at that position. If the position is bigger than the last element of the list, the last element position will be used.
\apierrors
\doerror{BADARG} The list or the new element pointer are\Null.
\returns
A pointer to the data of the given element or\Null if error.

\api{Save}
int (*Save)(List *l, FILE *stream,SaveFunction SaveFn, void *arg);
\end{verbatim}
\apidescription
The contents of the given list are saved into the given stream. If the save function pointer is not\Null, it will be used to save the contents of each element and will receive the arg argument passed to Save. Otherwise a default save function will be used and arg will be ignored.
\apierrors
\doerror{BADARG} The list pointer or the stream pointer are\Null.
EOF A disk input/output error occurred.
\returns
A positive value if the operation completed, a negative value or EOF otherwise.

\api{SetCompareFunction}
CompareFunction (*SetCompareFunction)(List l,CompareFunction f);
\end{verbatim}
\apidescription
if the f argument is non\Null, it sets the list comparison function to f.
\apierrors
\doerror{BADARG} The list pointer is\Null.
\doerror{READONLY} The list is read only and the function argument is not\Null.
\returns
The old value of the comparison function.
\example
    ErrorFunction fn,newfn;
    List *list;
    fn = iList.SetCompareFunction(list,newfn);
\end{verbatim}

\api{SetAllocator}
List *SetAllocator(List *l,ContainerMemoryManager  *allocator);
\end{verbatim}
\apidescription
Replaces the current allocator for the given list with the new one function if different from\Null. The list must be empty, and the new allocator must be able to allocate at least the size of the list header.
\apierrors
\doerror{BADARG} The list pointer is\Null.
\doerror{READONLY} The list is read only and the function argument is not\Null.
\returns
The old value of the allocator, or\Null if there is an error.


\api{SetErrorFunction}
    ErrorFunction (*SetErrorFunction)(List *L,ErrorFunction); 
\end{verbatim}
\apidescription
Replaces the current error function  for the given list with the new error function if different from\Null.
\apierrors
\doerror{BADARG} The list pointer is\Null.
\doerror{READONLY} The list is read only and the function argument is not\Null.
\returns
The old value of the error function, or\Null if there is an error.

\api{Size}
    size_t (*Size)(List *l);
\end{verbatim}
\apidescription
Returns the number of elements stored in the list.
\apierrors
If the given list pointer is\Null, it returns \textsc{SIZE\_MAX}.
\example
    List *li;
    size_t bytes = iList.Size(li);
\end{verbatim}
%--------------------------------------------------------------------------------------------------------------------------
\api{Sizeof}
    size_t (*Sizeof)(List *list);
\end{verbatim}
\apidescription
Returns the total size in bytes of the list, including the header, and all data stored in the list. If \texttt{list} is\Null, the result is the size of the \texttt{List} structure.
\returns
The number of bytes used by the list or the size of the empty List container if the argument is\Null.
\example
    List *list;
    size_t  siz = iList.Sizeof(list);
\end{verbatim}
%--------------------------------------------------------------------------------------------------------------------------
\api{Sort}
    int Sort(List *list);
\end{verbatim}
\apidescription
Sorts the given list using the list comparison function. The order of the original list is destroyed. You should copy it if you want to preserve it. 
\returns
A positive number if sorting succeeded, a negative error code if not.
\example
    List *list;
    if (iList.Sort(list) < 0) { /* Error handling */ }
\end{verbatim}
%--------------------------------------------------------------------------------------------------------------------------
\api{UseHeap}
    int (*UseHeap)(List *list,ContainerMemoryManager *m);
\end{verbatim}
\apidescription
Adds a heap manager to the given list, that should be empty. The heap manager will manage the free list and the allocation of new objects. Use this function when the list will hold a great number of elements. This function is optional and may not be present in all implementations.
If m is\Null, the current memory manager object will be used for allocating and reclaiming memory. Otherwise m should be a memory manager object.
\apierrors
\doerror{BADARG} The list pointer is\Null.
\doerror{NOT\_EMPTY} The list is not empty or has already a heap.

Portability:
This function is optional and may not be present in all implementations.
%--------------------------------------------------------------------------------------------------------------------------
%                                                   DOUBLE LINKED LISTS
%--------------------------------------------------------------------------------------------------------------------------
\section{Double linked lists: iDlist}
\index{lists!double linked}
Double linked lists have a pair of pointers pointing to the next and to the previous element in the list. It is easy then, to move in  either direction through the list. The price to pay is a higher overhead for each element.
This container shares most of its interface with the single linked list container.  Here we document the functions that aren't already described for the list container.
\index{iDlist}
\begin{verbatim}
typedef struct Dlist Dlist;
typedef struct {
    int (*Add)(Dlist *dlist,void *newVal);              
    Dlist *(*Append)(Dlist *l1,Dlist *l2);
    int (*Apply)(Dlist *L,int(ApplyFn)(void *,void *),void *arg);
    int (*Clear)(Dlist *dlist);                 
    int (*Contains)(Dlist *dlist,void *element);                
    Dlist *(*Copy)(Dlist *dlist);                  
    Dlist *(*Create)(size_t elementSize);
    Dlist *(*CreateWithAllocator)(size_t elementSize,
                   ContainerMemoryManager *,allocator);
    int (*deleteIterator)(Iterator *);
    int (*Equal)(Dlist *l1,Dlist *l2);
    int (*Erase)(Dlist *dlist,void *);                
    int (*EraseAt)(Dlist *dlist,size_t idx);              
    int (*Finalize)(Dlist *dlist);                                 
    size_t (*GetElementSize)(Dlist *);
    void *(*GetElement)(Dlist *dlist,int idx);             
    unsigned (*GetFlags)(Dlist *dlist);                               
    Dlist *(*GetRange)(Dlist *l,size_t start,size_t end);
    int (*IndexOf)(Dlist *dlist,void *SearchedElement,size_t *result);
    Dlist *(*Init)(Dlist *dlist,size_t elementsize);     
    int (*Insert)(Dlist *dlist,void *);
    int (*InsertAt)(Dlist *dlist,size_t idx,void *newVal);
    int (*InsertIn)(Dlist *l, size_t idx,Dlist *newData); 
    Dlist *(*Load)(FILE *stream, ReadFunction loadFn,void *arg);
    Iterator *(*newIterator)(Dlist *);
    int (*PopBack)(Dlist *AL,void *result);
    int (*PopFront)(Dlist *AL,void *result);
    int (*PushBack)(Dlist *AL,void *str);
    int (*PushFront)(Dlist *AL,void *str);
    int (*ReplaceAt)(Dlist *dlist,size_t idx,void *newVal); 
    Dlist *(*Reverse)(Dlist *l);                                
    int (*Save)(Dlist *L,FILE *stream, SaveFunction saveFn,void *arg);
    CompareFunction (*SetCompareFunction)(Dlist *l,CompareFunction Fn);
    ErrorFunction (*SetErrorFunction)(Dlist *L,ErrorFunction);
    unsigned (*SetFlags)(Dlist *dlist,unsigned flags);                    
    int (*Size)(Dlist *dlist);                 
    int (*Sort)(Dlist *l);                                        
    Dlist *(*Splice)(Dlist *list,
                     void *Pos,Dlist *toInsert,int direction);
    int (*UseHeap)(Dlist *L, ContainerMemoryManager *m);
} DlistInterface;

extern DlistInterface iDlist;
\end{verbatim}
\api{PopBack}
    int (*PopBack)(List *L,void *result);
\end{verbatim} 
\apidescription
Pops the element at position zero copying it to the result pointer. If the “result” pointer is\Null, the last element is removed without any copying. Otherwise, the library supposes that result points to at least ElementSize bytes of contiguous storage. 
\apierrors
\doerror{BADARG} The list or the result pointer are\Null.
\doerror{READONLY} The list is read only.
\returns
A positive value if an element was popped, zero if the list was empty, or a negative error code if an error occurred.
\example
    double d;
    int r = iList.PopBack(L,&d);
    if (r==0)
        printf("List empty\n”);
    else if (r < 0) {
        printf("Error %d\n”,r);
    else    printf("OK, popped value %g\n”,d);

PushBack
Synopsis:
    int (*PushBack)(List *L,void *element);
\end{verbatim} 
\apidescription
Inserts the given element at position zero. 
\apierrors
\doerror{BADARG} The list or the element pointer are\Null.
\doerror{READONLY} The list is read only.
\doerror{NOMEMORY} There is not enough memory to complete the operation.

\returns
A positive value if the operation completed, or a negative error code otherwise.
\example
    double d = 2.3;
    if (iList.PushFront(list,&d) < 0)
        printf("Error\n”);
\end{verbatim}
\api{Splice}
Synopsis:
Dlist *(*Splice)(Dlist *list, void *Pos, Dlist *toInsert,int direction);
\end{verbatim}
\apidescription
Inserts a list (parameter “toInsert”) into another one (parameter “list”) at the given position
that should be an element of “list”. The direction argument means to insert before the position if zero, after the position if not zero.
\apierrors
\doerror{BADARG} The list, the list to be inserted or the element pointer are\Null.
\doerror{READONLY} The list is read only.
%--------------------------------------------------------------------------------------------------------------------------
%                                                   ARRAYLIST
%--------------------------------------------------------------------------------------------------------------------------
\newpage
\section{The Vector interface: iVector}
The "vector” container is an array that resizes to accommodate new elements. Access is always checked against the array bounds.
Insertion and deletion of items are more expensive than in lists, and the cost increases linearly with the array size. Access is very cheap, since a multiplication suffices to get to any array position.

Most functions of the interface are shared with the list, Dlist and the other sequential containers.

\subsection{The interface}
\index{iVector}
\begin{verbatim}
typedef struct {
   int (*Add)(Vector *AL,void *newval);
   int (*AddRange)(Vector *AL,size_t n, void *newvalues);
   int (*Append)(Vector *AL1,Vector *AL2);
   int (*Apply)(Vector *AL,
                 int (*Applyfn)(void *elm,void *arg),
                 void *arg);
   int (*Clear)(Vector *AL);
   Vector *(*Create)(size_t elementsize,size_t startsize);
   Vector *(*CreateWithAllocator)(size_t elementsize,
                  size_t startsize,ContainerMemoryManager *allocator);
   int (*Contains)(Vector *AL,void *str,void *ExtraArgs);
   Vector *(*Copy)(Vector *AL);
   void **(*CopyTo)(Vector *AL);
   int (*deleteIterator)(Iterator *);
   int (*Erase)(Vector *AL,void *);
   int (*EraseAt)(Vector *AL,size_t idx);
   int (*Finalize)(Vector *AL);
   size_t (*Finalize)(Vector)(const Vector *AL);
   void *(*GetElement)(Vector *AL,size_t idx);
   size_t (*GetElementSize)(const Vector *AL);
   unsigned (*GetFlags)(const Vector *AL);
   Vector *(*GetRange)(Vector *AL,size_t start,size_t end);
   int (*IndexOf)(Vector *AL, void *elemToSearch,
                     void *ExtraArgs, size_t *result);
   int (*Insert)(Vector *AL,void *);
   int (*InsertAt)(Vector *AL,size_t idx,void *newval);
   int (*InsertIn)(Vector *l, size_t idx,Vector *newData)
   Vector *(*Load)(FILE *stream, ReadFunction readFn,void *arg);
   int (*Mismatch)(const Vector *a1,const Vector *a2,
                                              size_t *result);
   Iterator *(*newIterator)(Vector *AL);
   int (*PushBack)(Vector *AL,void *element);
   int (*PopBack)(Vector *AL,void *result);
   int (*ReplaceAt)(Vector *AL,size_t idx,void *newval);
   int (*Reverse)(Vector *AL);
   int (*SetCapacity)(Vector *AL,size_t newCapacity);
   CompareFunction (*SetCompareFunction)(Vector *AL,
                    CompareFunction f);
   ErrorFunction (*SetErrorFunction)(Vector *AL,ErrorFunction);
   unsigned (*SetFlags)(Vector *AL,unsigned flags);
   size_t (*Size)(const Vector *AL);
   size_t (*Sizeof)(Vector *AL);
   int (*Sort)(Vector *AL);
   int (*Save)(Vector *AL,FILE *stream, SaveFunction Fn,void *arg);
} VectorInterface;
\end{verbatim}
\subsection{The API}
\api{Add}
    int (*Add)(Vector *AL,void *data);
\end{verbatim} 
\apidescription
Adds the given element to the end of the container. It is the same operations as the PushBack operation. It is assumed that “data” points to a contiguous memory area of at least ElementSize bytes. Returns a value greater than zero if the addition completed successfully, a negative error code otherwise. 
\apierrors
\doerror{BADARG} The vector or the data pointers are\Null.
\doerror{READONLY} The vector is read-only. No modifications allowed.
\doerror{NOMEMORY} Not enough memory to complete the operation.
\returns
A positive number if the operation completed, negative error code otherwise.
\example
    Vector *AL;
    double data = 4.5;
    int result = iVector.Add(AL,&data);
    if (result < 0) { /* Error handling */ }
\end{verbatim}

\api{AddRange}
    int (*Add)(Vector *AL,size_t n, void *data);
\end{verbatim} 
\apidescription
Adds the n given elements to the end of the container. It is the same operations as the PushBack operation. It is assumed that “data” points to a contiguous memory area of at least n*ElementSize bytes. Returns a value greater than zero if the addition completed successfully, a negative error code otherwise. If n is zero no error is issued even if the array pointer or the data pointer are\Null.
\apierrors
\doerror{BADARG} The vector or the data pointers are\Null, and n is not zero.
\doerror{READONLY} The vector is read-only. No modifications allowed.
\doerror{NOMEMORY} Not enough memory to complete the operation.
\returns
A positive number if the operation completed, negative error code otherwise.
\example
    Vector *AL;
    double data[] = {4.5, 4.6, 4.7 };
    int result = iVector.Add(AL,3, data);
    if (result < 0) { /* Error handling */ }
\end{verbatim}


\api{Append}
  int (*Append)(Vector *AL1, Vector *AL2);
\end{verbatim}
\apidescription
Adds all elements of AL2 at the end of the first container AL1.
\apierrors
\doerror{BADARG} One of the Vector pointer is\Null.
\doerror{READONLY} The first argument is read-only. No modifications allowed.
\doerror{NOMEMORY} Not enough memory to complete the operation.
\returns
A positive number if the operation completed, negative error code otherwise.

\api{Apply}
    int (*Apply)(Vector l,int (Applyfn)(void *,void *),void *arg);
\end{verbatim} 
\apidescription
Will call the given function for each element of the array. The first argument of the callback function receives an element of the array. The second argument of the callback is the arg argument that the Apply function receives and passes to  the callback. This way some context can be passed to the callback, and from one element to the next.
Note that the result of the callback is not used. This allows all kinds of result types to be accepted after a suitable cast.
If the array is read-only, a copy of the element will be passed to the callback function.
\apierrors
\doerror{BADARG} Either list or Applyfn are\Null.
\doerror{NOMEMORY} The list is read-only and there is no more memory to allocate the buffer to copy each element.
\returns
A positive value if no errors or a negative error code.
\example
    static int Callback(void *pelement,void *pResult)
    {
        double *p = pelement;
        double *result = pResult;
        *pResult += *p;
        return 1;
    }
    double AddVector(Vector *l) {
        double sum = 0;
        Vector *alist = iVector.Create(sizeof(double));
        double d = 2;
        iVector.Add(list,&d);
        d = 3;
        iVector.Add(alist,&d);
        iList.Apply(alist,Callback,&sum);
        // Here sum should be 5.
        return sum;
    }
\end{verbatim}

\api{Clear}
    int (*Clear)(Vector *l);
\end{verbatim} 
\apidescription
Erases all stored data and releases the memory associated with it. The vector header will not be destroyed, and its contents will be the same as when the array was initially created. It is an error to use this function when there are still active iterators for the container.
\returns
The result is greater than zero if successful, or an error code if an error occurs. 
\apierrors
\doerror{BADARG} The vector pointer is\Null.
\doerror{READONLY} The vector is read only.
\example
    Vector *Al;
    int m = iVector.Clear(Al);
\end{verbatim}

\api{Contains}
    int (*Contains)(Vector *a,void *data);
\end{verbatim} 
\apidescription
Searches the given data in the array. The “data” argument is supposed to point to an element at least ElementSize bytes. The list's comparison function is used for determining if two elements are equal. This comparison function defaults to memcmp.
\apierrors
\doerror{BADARG} Either array or data are\Null.
\returns
One if the given data is stored in the list, zero otherwise. If either daata pointer or the array pointer are\Null returns a negative error code.
\example
    Vector *a;
    int r = iVector.Contains(a,&data);
\end{verbatim}

\api{Copy}
    Vector *(*Copy)(Vector *A);
\end{verbatim} 
\apidescription
A shallow copy of the given array is performed. Only ElementSize bytes will be copied for each element. If the element contains pointers, only the pointers are copied, not the objects they point to. The new memory will be allocated using the given array's allocator.
\apierrors
\doerror{NOMEMORY} There is not enough memory to complete the operation.
\doerror{BADARG} The given vector pointer is\Null.
\example
    Vector *newVector,*OldVector;
    newVector = iVector.Copy(OldVector);
\end{verbatim}

\api{Create}
    Vector *(*Create)(size_t element_size,size_t startsize);
\end{verbatim} 
\apidescription
The creation function returns an empty array, initialized with all the default values.
The current memory manager is used to allocate the space needed for the header. The array is supposed to contain elements of the same size. If the elements you want to store are of different size, use a pointer to them, and create the list with sizeof(void *) as the size parameter.

\returns
A pointer to a newly created List or\Null if an error occurs.
\apierrors
\doerror{NOMEMORY} There is not enough memory to complete the operation.
\doerror{BADARG} The given element size is zero.

Any errors provoke the call the current default error function of the library since this is the creation function.
\example
    Vector *DArray = iVector.Create(sizeof(double),100);
\end{verbatim}
\api{CreateWithAllocator}
Vector *(*CreateWithAllocator)(size_t elementsize,
                    size_t startsize,ContainerMemoryManager *allocator);
\end{verbatim}
\apidescription
This function is identical to \texttt{Create} with the difference that it accepts a pointer to an allocator object. Actually, \texttt{Create} can
be written as:\par\noindent
\texttt{return CreateWithAllocator(elementsize,startsize,CurrentMemoryManager);}


\api{Contains}
    int (*Contains)(Vector *AL,void *data);
\end{verbatim}
\apidescription
Searches for the given data in the array. The “data” argument is supposed to point to an element at least ElementSize bytes. The array's comparison function is used for determining if two elements are equal. This comparison function defaults to memcmp.
\returns
One if the given data is stored in the list, zero otherwise. If an error occurs, it returns a negative error code.
\apierrors
\doerror{BADARG} Either list or data are\Null.
\example
    Vector *AL;
    int r = iVector.Contains(AL,&data);
\end{verbatim}
\api{CopyTo}
void **(*CopyTo)(Vector *AL);
\end{verbatim}
\apidescription
Copies the whole contents of the given array list into a table of pointers to newly allocated elements, finished by a\Null pointer.
\apierrors
\doerror{BADARG} The iterator pointer is\Null.
\doerror{NOMEMORY} There is not enough memory to complete the operation.
\returns
A pointer to a table of pointers or\Null if an error occurs.
\api{deleteIterator}
    int deleteIterator(Iterator *it);
\end{verbatim}
\apidescription
Reclaims the memory used by the given iterator object
\returns 
Integer smaller than zero with error code or a positive number when the operation completes.
\apierrors
\doerror{BADARG} The iterator pointer is\Null.

\api{Equal}
    int (*Equal)(Vector *first,Vector *second);
\end{verbatim}
\apidescription
Compares the given arrays. If they differ in their length, flags, or element size they compare unequal. If any of their elements differ, they compare unequal.
If both first and second are\Null they compare equal. 
\apierrors
None
\returns
The result is one if the lists are equal, zero otherwise.

\api{Erase}
    int (*Erase)(Vector *AL,void *data);
\end{verbatim}
\apidescription
Removes from the list the element that matches the given data, that is assumed to be a pointer to an element.

\returns
A negative error code if an error occurred, or a positive value that indicates that a match was found and the element was removed. If the element is not in the list the result value is CONTAINER\_ERROR\_NOT\_FOUND.

\apierrors
\doerror{BADARG} One or both arguments are\Null.

\example
    double d = 2.3;
    Vector *AL;
    int r = iVector.Erase(AL,&d);
    if (r > 0)
        printf("2.3 erased|n”);
    else if (r == 0)
        printf("No element with value 2.3 present\n”);
    else
        printf("error code %d\n”,r);
\end{verbatim}

\api{EraseAt}
    int (*EraseAt)(Vector *AL,size_t idx);
\end{verbatim}
\apidescription
Removes from the array the element at the given position.

\returns
A negative error code if an error occurred or a positive value that indicates that the element was removed.

\apierrors
\doerror{BADARG} The given vector pointer is\Null.
\doerror{INDEX} The given position is out of bounds.

\example
    Vector *AL;
    int r = iVector.EraseAt(AL,2);
    if (r > 0)
        printf("Element at position 2 erased\n”);
    else
        printf("Error code %d\n”,r);
\end{verbatim}
\api{Finalize}
    int (*Finalize)(Vector *AL);
\end{verbatim}
\apidescription
Reclaims all memory used by the container, including the array header object itself.
\apierrors
\doerror{BADARG} The given list pointer is\Null.
\doerror{READONLY} The container is read-only. No modifications allowed.
\returns
A positive value means the operation completed. A negative error code indicates failure.
\example
    Vector *AL;
    int r = iVector.Finalize(AL);
    if (r < 0) { /* error handling */ }
\end{verbatim}
\api{GetCapacity}
    size_t (*GetCapacity)(Vector *AL);
\end{verbatim}
\apidescription
Returns the number of elements the array can hold before  it needs to reallocate its data.
\apierrors
\doerror{BADARG} The given array is\Null.
\returns
The array capacity or zero if there was an error.
\api{GetElementSize}
    size_t (*GetElementSize)(Vector *AL);
\end{verbatim}
\apidescription
Retrieves the size of the elements stored in the given list. Note that this value can be different than the value given to the creation function because of alignment requirements.
\apierrors
\doerror{BADARG} The given list pointer is\Null.

\returns
The element size.
\example
    Vector *AL;
    size_t siz = iVector.GetElementSize(AL);
\end{verbatim}

\api{GetElement}
    void *(*GetElement)(Vector *AL,size_t idx);
\end{verbatim}
\apidescription
Returns a read only pointer to the element at the given index, or\Null if the operation failed.  This function will return\Null if the list is read only.
 
Use the CopyElement function to get a read/write copy of an element of the list.

\apierrors
\doerror{BADARG}    The given array pointer is\Null.
\doerror{INDEX}    The given position is out of bounds.
\doerror{READONLY}    The array is read only.
\example
    Vector *AL;
    double *d = iList.GetElement(AL,3);
    if (d == NULL) { /* Error handling */ }
\end{verbatim}

\api{GetFlags / SetFlags}
    unsigned (*GetFlags)(Vector *AL);
    unsigned (*SetFlags)(Vector *AL,unsigned newFlags);
\end{verbatim}
\apidescription
GetFlags returns the state of the container flags, SetFlags sets the flags to a new value and returns the old value. 

The Vector container supports the following flags:

\textsc{CONTAINER\_LIST\_READONLY}
If this flag is set, no modifications to the container are allowed, and the Clear and Finalize functions will not work. The GetElement function will always return\Null. You should use the CopyElement function to access the data

\api{GetRange}
    Vector *(*GetRange)(Vector *AL,size_t start,size_t end);
\end{verbatim}
\apidescription
Selects a series of consecutive elements starting at position start and ending at position end.  Both the elements at start and end are included in the result.
If start > end or start > list->count, an empty list is returned. If end is bigger than the number of elements in list, only elements up to the number of elements will be used.
The selected elements are copied into a new list. The original list remains unchanged.
\apierrors
\doerror{BADARG} The given list pointer or the element given are\Null
\returns:
A pointer to a new list containing the selected elements or\Null if an error occurs.
\example
    Vector *AL;
    Vector *range = iVector.GetRange(AL,2,5);
    if (range == NULL) { /* Error handling */ }
\end{verbatim}

\api{IndexIn}
Vector *(*IndexIn)(Vector *SC,Vector *AL);
\end{verbatim}
\apidescription
Returns an array built from indexing the first argument ("SC") with the array of indexes "AL" that should be an array of size\_t elements. The number of elements of the resulting array is equal to the number of elements of the indexes array.
\apierrors
\doerror{BADARG} The given array pointer or the indexes array are\Null.
\doerror{INDEX} Any given position is out of bounds.
\doerror{NOMEMORY} There is not enough memory to complete the operation.
\returns
A new arraylist or\Null if an error occurs. No partial results are returned. If any index is out of bounds the whole operation fails.

\api{IndexOf}
int (*IndexOf)(Vector *l,void *data,void *ExtraArgs,size_t *result);
\end{verbatim}
\apidescription
Searches for an element in the array. If found its zero based index is returned in the pointer "result". Otherwise the result of the search is \doerror{NOTFOUND}. The “extraArgs” argument will be passed to the comparison function, that is used to compare elements.
\apierrors
\doerror{BADARG} The given array pointer or the element given are\Null.
\returns
A positive number if the element is found, or a negative number containing an error code or the negative constant CONTAINER\_ERROR\_NOTFOUND.
\example
    Vector *AL;
    double data = 6.8;
    size_t pos;
    int r = iVector.IndexOf(AL,&data,NULL,&pos);
    if (r == CONTAINER_ERROR_NOTFOUND)
        printf("Not found\n”);
\end{verbatim}

\api{InsertAt}
    int (*InsertAt)(Vector *AL,size_t idx,void *newData);
\end{verbatim}
\apidescription
Inserts the new element. The new element will have the given index, that can go from zero to the list count inclusive, i.e. one more than the number of elements in the list. In single linked lists the cost for this operation is proportional to idx.
\apierrors
\doerror{BADARG} The given list pointer or the element given are\Null.
\doerror{READONLY} The list is read only.
\doerror{INDEX} The given position is out of bounds.
\doerror{NOMEMORY} There is not enough memory to complete the operation.

\returns
A positive value if the operation succeeded, or a negative error code if the operation failed.
\example
    double d;
    Vector *AL;
    int r = iVector.InsertAt(AL,2,&d);
    if (r < 0) { /* Error handling */ }
    else { /* Normal processing */  }
\end{verbatim}

\api{InsertIn}
    int (*InsertIn)(Vector *Destination, size_t pos, Vector *src);
\end{verbatim}
\apidescription
Inserts the array given in  its third argument at the given position in the array pointed to by its first argument. The data is copied, and the source argument is not modified in any way. Both arrays must have elements of the same type. The library only tests the size of each one.
\apierrors
\doerror{BADARG} The source or the destination lists are\Null.
\doerror{READONLY} The destination list is read only.
\doerror{INDEX} The given position is out of bounds.
\doerror{NOMEMORY} There is not enough memory to complete the operation.
\doerror{INCOMPATIBLE} The lists store elements of different size.
\returns
A positive value if the operation succeeded, or a negative error code if the operation failed.
\example
#include <containers.h>
static void PrintVector(Vector *AL)
{
    size_t i;
    printf("Count %ld, Capacity %ld\n",(long)iVector.Size(AL),
                                  (long)iVector.GetCapacity(AL));
    for (i=0; i<iVector.Size(AL);i++) {
        printf("%g ",*(double *)iVector.GetElement(AL,i));
    }
    printf("\n");
}

static void FillVector(Vector * AL,int start)
{
    size_t i;

    for (i=0; i<10;i++) {
        double d = i+start;
        iVector.Add(AL,&d);
    }
}

int main(void)
{
    Vector *AL = iVector.Create(sizeof(double),10);
    Vector *AL1 =iVector.Create(sizeof(double),10);
    FillVector(AL,0);
    FillVector(AL1,100);
    iVector.InsertIn(AL,5,AL1);
    PrintVector(AL);
    return 0;
}
OUTPUT:
Count 20, Capacity 20
0 1 2 3 4 100 101 102 103 104 105 106 107 108 109 5 6 7 8 9

\end{verbatim}
\api{Load}
   Vector *(*Load)(FILE *stream,ReadFunction readFn,void *arg);
\end{verbatim}
\apidescription
Reads an array previously saved with the Save function from the stream pointed to by stream. If readFn is not\Null, it will be used to read each element. The “arg” argument will be passed to the read function. If the read function is\Null, this argument is ignored and a default read function is used.
\apierrors
\doerror{BADARG} The given stream pointer is\Null.
\doerror{NOMEMORY} There is not enough memory to complete the operation.

\returns
A new array or\Null if the operation could not be completed. Note that the function pointers in the array are NOT saved, nor any special allocator that was in the original list. Those values will be the values by default. To rebuild the original state the user should replace the pointers again in the new array.

\api{newIterator}
    Iterator *(*newIterator)(Vector *AL);
\end{verbatim}
\apidescription
Allocates and initializes a new iterator object to iterate this array.
\apierrors
If no more memory is available it returns\Null.
\returns
A pointer to a new iterator or\Null if there is no more memory left.
\example
    Vector *AL;
    Iterator *it = iVector.newIterator(AL);
    double *d;
    for (d=it->GetFirst(it); d != NULL; d = it->GetNext(it)) {
        double val = *d;
        // Work with the value here
    }
    iVector.deleteIterator(it);
\end{verbatim}

\api{Mismatch}
int (*Mismatch)(const Vector *a1,const Vector *a2,
                                         size_t *mismatch);
\end{verbatim}
\apidescription
Returns the index of the first element that is different when comparing both arrays in the passed pointer \textsl{mismatch}. If one array is shorter than the other the comparison stops
when the last element from the shorter array is compared. The comparison stops when the first difference is spotted.
\apierrors
\doerror{BADARG} Any of the arguments is\Null.
\returns
If a mismatch is found the result is greater than zero and the \textsl{mismatch} argument will contain the index of the first element that compared 
unequal. This will be always the case for arrays of different length.

If both arrays are the same length and no differences are found the result is zero and the value pointed to by the 
\textsl{mismatch} argument is one more than the length of the arrays.

If an error occurs, a negative error code is returned. The \textsl{mismatch} argument contains zero.
\api{PopBack}
    int (*PopBack)(Vector *AL,void *result);
\end{verbatim}
\apidescription
Copies the last element into the given result buffer and deletes the element from the container. If the result buffer is\Null, no copy is performed.
\apierrors
\doerror{BADARG} The array is\Null.
\doerror{READONLY} The array is read only.

\returns
A negative value if an error occurs, zero if the array is empty or greater than zero if the operation succeeded.
\api{ReplaceAt}
    int (*ReplaceAt)(Vector *AL,size_t idx,void *newData);
\end{verbatim}
\apidescription
Replaces the array element at position idx with the new data starting at the position pointed to by “newData” and extending ElementSize bytes.
\apierrors
\doerror{BADARG} The array or the new element pointer are\Null.
\doerror{READONLY} The array is read only.
\doerror{INDEX} The given position is out of bounds.
\returns
A negative error code if an error occurs, or a positive value if the operation succeeded.
\example
    Vector *AL;
    double d = 6.7;
    int r = iVector.ReplaceAt(AL,2,&d);
    if (r < 0) { /* Error handling */ }
\end{verbatim}

\api{Reverse}
int (*Reverse)(Vector *AL);
\end{verbatim}
\apidescription
Reverses the order of the elements of the given Vector.
\apierrors
\doerror{BADARG} The array pointer is\Null.
\doerror{READONLY} The array is read only.
\doerror{NOMEMORY} Not enough memory for intermediate storage available
\returns
A negative error code if an error occurs, or a positive value if the operation succeeded.

\api{Save}
int (*Save)(Vector *AL, FILE *out, SaveFunction Fn, void *arg);
\end{verbatim}
\apidescription
The contents of the given list are saved into the given stream. If the save function pointer is not\Null, it will be used to save the contents of each element and will receive the arg argument passed to Save, together with the output stream. Otherwise a default save function will be used and arg will be ignored.
The output stream must be opened for writing and must be in binary mode.
\apierrors
\doerror{BADARG} The array pointer or the stream pointer are\Null.
EOF A disk input/output error occurred.

\returns
A positive value if the operation completed, a negative value or EOF otherwise.
\example
    Vector *AL;
    FILE *outFile;
    if (iVector.Save(AL,outFile,NULL,NULL) < 0) { 
        /* Handle error here */
    }
\end{verbatim}
\api{SetCapacity}
int (*SetCapacity)(Vector *AL,size_t newCapacity);
\end{verbatim}
\apidescription
Resizes the given Vector to a new value. The new capacity means there will be that number of elements allocated, avoiding costly resizing operations when new elements are added to the Vector. If the number given is less than the number of elements present in the array, elements are discarded from the end of the array.
\apierrors
\doerror{BADARG} The Vector pointer is\Null.
\doerror{READONLY} The array is read only.
\returns A positive value if resizing was completed, a negative error code otherwise.

\api{SetCompareFunction}
CompareFunction (*SetCompareFunction)(Vector *AL,
                                         CompareFunction f);
\end{verbatim}
\apidescription
if the f argument is non\Null, it sets the array comparison function to f.
\apierrors
\doerror{BADARG} The array pointer is\Null.
\doerror{READONLY} The array is read only and the function argument is not\Null.
\returns
The old value of the comparison function.
\example
    ErrorFunction fn,newfn;
    Vector *AL;
    fn = iVector.SetErrorFunction(AL,newfn);
\end{verbatim}

\api{SetErrorFunction}
    ErrorFunction (*SetErrorFunction)(List *L,ErrorFunction); 
\end{verbatim}
\apidescription
Replaces the current error function  for the given list with the new error function if different from\Null.
\apierrors
\doerror{BADARG} The list pointer is\Null.
\doerror{READONLY} The list is read only and the function argument is not\Null.
\returns
The old value of the error function or\Null if there is an error.

\api{Size}
    size_t (*Size)(Vector *AL);
\end{verbatim}
\apidescription
Returns the number of elements stored in the array.
\example
    Vector *AL;
    size_t elem = iVector.Size(AL);
\end{verbatim}

\api{Sizeof}
    size_t (*Sizeof)(Vector *AL);
\end{verbatim}
\apidescription
Returns the total size in bytes of the list, including the header, and all data stored in it. If the argument is\Null, the size of the header only is returned.
\returns
The number of bytes used by the list or the size of the Vector header if the argument is\Null.
\example
    Vector *AL;
    size_t  size = iVector.Sizeof(AL);
\end{verbatim}

\api{Sort}
    int Sort(Vector *AL);
\end{verbatim}
\apidescription
Sorts the given array using the its comparison function. The order of the original array is destroyed. You should copy it if you want to preserve it. 
\returns
A positive number if sorting succeeded, a negative error code if not.
\example
    Vector *AL;
    if (iVector.Sort(AL) < 0) { /* Error handling */ }
\end{verbatim}
%--------------------------------------------------------------------------------------------------------------------------
%                                                   Bit strings
%--------------------------------------------------------------------------------------------------------------------------
\newpage
\section{The bit-string container: iBitString}
A bit string is a derivation from the Vector container, specialized to hold a sequence of bits. It is a sequential container designed to save space in the storage of boolean values. 
\subsection{The interface}
\index{iBitString}
\begin{verbatim}
typedef struct {
    int (*Add)(BitString *BitStr,int);
    BitString *(*And)(BitString *bsl,BitString *bsr);
    BitString *(*AndAssign)(BitString *bsl,BitString *bsr);
    int (*Append)(BitString *left,BitString *right);
    int (*Apply)(BitString *B,int (*Applyfn)(int ,void *),void *);
    uintmax_t  (*BitsBlockCount)(BitString *b);
    int (*Clear)(BitString *BitStr);
    int (*Contains)(BitString *B,BitString *str,void *ExtraArgs);
    BitString *(*Copy)(BitString *);
    BitString *(*Create)(size_t bitlen);
    int (*deleteIterator)(Iterator *);
    int (*Equal)(BitString *bsl,BitString *bsr);
    int (*Erase)(BitString *BitStr,bool bit);
    int (*EraseAt)(BitString *BitStr,size_t idx);
    int (*Finalize)(BitString *BitStr);
    size_t (*GetCapacity)(BitString *BitStr);
    int (*GetElement)(BitString *BitStr,size_t idx);
    size_t GetElementSize(BitString *b);
    unsigned (*GetFlags)(BitString *BitStr);
    BitString *(*GetRange)(BitString *b,size_t start,size_t end);
    int (*IndexOf)(BitString *B,bool SearchedBit,
    size_t (*Insert)(BitString *BitStr,bool bit);
    size_t (*InsertAt)(BitString *BitStr,size_t idx,bool bit);
    BitString *(*LeftShift)(BitString *bs,size_t shift);
    BitString *(*Load)(FILE *stream, ReadFunction Fn,void *arg);
    int       (*LessEqual)(BitString *bsl,BitString *bsr);
    Iterator  *(*newIterator)(BitString *);
    BitString *(*Not)(BitString *bsl);
    BitString *(*NotAssign)(BitString *bsl);
    BitString *(*ObjectToBitString)(unsigned char *p,size_t size);
    BitString *(*Or)(BitString *left,BitString *right);
    BitString *(*OrAssign)(BitString *bsl,BitString *bsr);
    int (*Pop)(BitString *BitStr);
    uintmax_t  (*PopulationCount)(BitString *b);
    size_t (*Print)(BitString *b,size_t bufsiz,unsigned char *out);
    int (*Push)(BitString *BitStr,int val);
    int (*ReplaceAt)(BitString *BitStr,size_t idx,bool newval);
    BitString *(*Reverse)(BitString *b);
    BitString *(*RightShift)(BitString *bs,size_t shift);
    int  (*Save)(BitString *B,FILE *out, SaveFunction Fn,void *arg);
    int (*Set)(BitString *,size_t start,size_t stop,bool newval);
    int    (*SetCapacity)(BitString *BitStr,size_t newCapacity);
    int    (*SetElement)(BitString *bs,size_t position,bool b);
    ErrorFunction *(*SetErrorFunction)(BitString *,ErrorFunction);
    unsigned (*SetFlags)(BitString *BitStr,unsigned flags);
    size_t (*Size)(BitString *BitStr);
    size_t (*Sizeof)(BitString *b);
                   void *ExtraArgs,size_t *result);
    BitString *(*StringToBitString)(unsigned char *);
    BitString *(*Xor)(BitString *bsl,BitString *bsr);
    BitString *(*XorAssign)(BitString *bsl,BitString *bsr);
} BitStringInterface;
\end{verbatim}
\subsection{API}
Contrary to the other containers presented above like \texttt{iList} or \texttt{iVector}, bitstring receives and returns not pointers but values of bits. This is an important difference and makes for significant changes in the interface of many functions.

Other functions like \texttt{Apply} do not make much sense for bits and are provided  just to be coherent in the obverall design of the library. Obviously a function that needs a function call per bit is not very fast.
The function GetElementSize is provided for compatibility purposes only and returns always 1. Actually it should return 0.125 assuming
8 bits bytes.

\api{Or}
    BitString *(*Or)(BitString *left,BitString *right);
\end{verbatim}
\apidescription
Makes a logical OR between the left and right arguments. The result is returned in a new bit string, both arguments are not modified. The length of the resulting bit string is the smallest length of both strings.
\apierrors
\doerror{BADARG} One of both bitstring pointers are\Null.
\doerror{NOMEMORY} Not enough memory is available to complete the operation.


\api{And}
    BitString *(*And)(BitString *left,BitString *right);
\end{verbatim}
\apidescription
Makes a logical AND between the left and right arguments. The result is returned in a new bit string, both arguments are not modified. The length of the resulting bit string is the smallest length of both strings.
\returns
A pointer to the newly allocated result or\Null in case of error.

\apierrors
\doerror{BADARG} One of both bitstring pointers are\Null.
\doerror{NOMEMORY} Not enough memory is available to complete the operation.
\api{AndAssign}
    BitString *(*AndAssign)(BitString *left,BitString *right);
\end{verbatim}
\apidescription
Makes a logical AND of its two arguments and assigns the result into the left bit string. If the bit strings have a different length, the operation uses the bits of the right argument until either the end of the right argument or the end of the destination string is reached.
\returns
A pointer to its left argument or\Null in case of error.
\apierrors
\doerror{BADARG} One or both arguments are\Null.

\api{GetRange}
BitString *(*GetRange)(BitString *b,size_t start,size_t end);
\end{verbatim}
\apidescription
Returns all the bits between the start (inclusive) and the end (inclusive) indices. If $end$ is smaller than $start$, $start$ and $end$ are exchanged.
If $end$ is greater than the size of the bit string, all elements up to the last one are returned. If both $start$ and $end$ are out of range, an error is issued and the result is\Null.
\returns
A new bit string with the specified contents.
\apierrors
\doerror{BADARG} The given argument is\Null.

\api{Not}
    BitString *(*Not)(BitString *src);
\end{verbatim}
\apidescription
Makes a logical NOT of its argument. The result is returned in a new bit string. The length of the resulting bit string is the same as the length of the argument.
\returns
A pointer to the newly allocated bit string or\Null in case of error.
\apierrors
\doerror{BADARG} The argument is\Null.
\doerror{NOMEMORY} Not enough memory is available to complete the operation.

\api{NotAssign}
    BitString *(*NotAssign)(BitString *src);
\end{verbatim}
\apidescription
Makes a logical NOT of its argument and assigns the result into it. 
\returns
A pointer to its argument or\Null in case of error.
\apierrors
\doerror{BADARG} The argument is\Null.

\api{Or}
    BitString *(*Or)(BitString *left,BitString *right);
\end{verbatim}
\apidescription
Makes a logical OR between the left and right arguments. The result is returned in a new bit string, both arguments are not modified. The length of the resulting bit string is the smallest length of both strings.
\apierrors
\doerror{BADARG} One of both bitstring pointers are\Null.
\doerror{NOMEMORY} Not enough memory is available to complete the operation.

\api{OrAssign}
    BitString *(*OrAssign)(BitString *left,BitString *right);
\end{verbatim}
\apidescription
Makes a logical OR of its two arguments and assigns the result into the left bit string. If the bit strings have a different length, the operation uses the bits of the right argument until either the end of the right argument or the end of the destination string is reached.
\apierrors
\doerror{BADARG} One or both arguments are\Null.

\api{PopulationCount}
uintmax_t  (*PopulationCount)(BitString *b);
\end{verbatim}
\apidescription
Computes the number of 1 bits in the bit string.
\returns
The number of set bits in the string.
\apierrors
\doerror{BADARG} The given argument is\Null.

\api{Reverse}
    BitString *(*Reverse)(BitString *b);
\end{verbatim}
\apidescription
The bit sequence of the argument is reversed
\returns
A new bit string containing the reversed argument.
\apierrors
\doerror{BADARG} The given argument is\Null.
\api{BitBlockCount}
uintmax_t  (*BitBlockCount)(BitString *b);
\end{verbatim}
\apidescription
Computes the number of blocks where 1 or more bits are set.
\returns
The number of blocks of set bits.
\apierrors
\doerror{BADARG} The given argument is\Null.

\api{Xor}
    BitString *(*Xor)(BitString *left,BitString *right);
\end{verbatim}
\apidescription
Makes a logical XOR between the left and right arguments. The result is returned in a new bit string, both arguments are not modified. The length of the resulting bit string is the smallest length of both strings.
\returns
A pointer to its result or\Null in case of error.
\apierrors
\doerror{BADARG} One of both bitstring pointers are\Null.
\doerror{NOMEMORY} Not enough memory is available to complete the operation.
\api{XorAssign}
    BitString *(*XorAssign)(BitString *left,BitString *right);
\end{verbatim}
\apidescription
Makes a logical XOR of its two arguments and assigns the result into the left bit string. If the bit strings have a different length, the operation uses the bits of the right argument until either the end of the right argument or the end of the destination string is reached.
\returns
A pointer to its left argument or\Null in case of error.
\apierrors
\doerror{BADARG} Its argument is\Null.

%--------------------------------------------------------------------------------------------------------------------------
%                                                   STRING COLLECTION
%--------------------------------------------------------------------------------------------------------------------------
\newpage
\section{The string collection container: iStringCollection}
A string collection is a derivation from the Vector container, specialized to hold character strings.
\subsection{The interface}
\index{iStringCollection}
\begin{verbatim}
typedef struct {
    int (*Add)(StringCollection *SC,char *newval);
    int (*AddRange)(StringCollection *SC,char **newvalues);
    int (*Apply)(StringCollection *SC,
                  int (*Applyfn)(char *,void * ExtraArg),
                  void *ExtraArg);
    Vector *(*CastToArray)(StringCollection *SC);
    int (*Clear)(StringCollection *SC);
    int (*Contains)(StringCollection *SC,char *str);
    StringCollection *(*Copy)(StringCollection *SC);
    char **(*CopyTo)(StringCollection *SC);
    StringCollection *(*Create)(size_t startsize);
    StringCollection *(*CreateWithAllocator)(size_t startsize,
                           ContainerMemoryManager *allocator);    
    StringCollection *(*CreateFromFile)(unsigned char *fileName);
    int (*deleteIterator)(Iterator *);
    int (*Equal)(StringCollection *SC1,StringCollection *SC2);
    int (*Erase)(StringCollection *SC,char *);
    int (*EraseAt)(StringCollection *SC,size_t idx);
    int (*Finalize)(StringCollection *SC);
    size_t (*FindFirstText)(StringCollection *SC,char *text);
    size_t (*FindNextText)(StringCollection *SC,char *txt,size_t start);
    Vector *(*FindTextPositions)(StringCollection *SC,char *text);
    Vector *(*FindTextPositions)(StringCollection *SC,char *text);
    ContainerMemoryManager *(GetAllocator)(StringCollection *AL);
    int (*GetCapacity)(StringCollection *SC);
    char *(*GetElem ent)(StringCollection *SC,size_t idx);
    unsigned (*GetFlags)(StringCollection *SC);
    int (*IndexOf)(StringCollection *SC,
            char *SearchedString,size_t *result);
    int (*Insert)(StringCollection *SC,char *);
    int (*InsertAt)(StringCollection *SC,size_t idx,char *newval);
    int (*InsertIn)(StringCollection *source, size_t idx, 
                    StringCollection *newData);
    StringCollection *(*Load)(FILE *stream, 
                              ReadFunction readFn,void *arg);
    int (*Mismatch)(const Vector *a1,const Vector *a2,
                                                size_t *result);

    Iterator *(*newIterator)(StringCollection *SC);
    size_t (*PopBack)(StringCollection *SC,char *buffer,size_t buflen);
    int (*PushBack)(StringCollection *SC,char *str);
    int (*ReplaceAt)(StringCollection *S,size_t idx,char *newV);
    int (*SetCapacity)(StringCollection *SC,size_t newCapacity);
    StringCompareFn (*SetCompareFunction)(StringCollection *SC,
                     StringCompareFn StrCmp);
    ErrorFunction (*SetErrorFunction)(StringCollection *S, 
                   ErrorFunction Fn);
    unsigned (*SetFlags)(StringCollection *SC,unsigned flags);
    size_t (*Size)(StringCollection *SC);
    size_t (*Sizeof)(StringCollection *SC);
    int (*Save)(StringCollection *SC,
                 FILE *stream, SaveFunction saveFn, void *arg);
    int (*Sort)(StringCollection *SC);
    int (*WriteToFile)(StringCollection *SC,unsigned char *fileName);
} StringCollectionInterface;

extern StringCollectionInterface iStringCollection;
\end{verbatim}
\subsection{API}
Most of the functions present in the interface are exactly like the functions in Vector. Only those that differ will be documented here.

\api{AddRange}
    int (*AddRange)(StringCollection *SC,size_t n,char *data[]);
\end{verbatim}
\apidescription
Adds each string of the array of string pointers at the end of the container. It is assumed that “data” points to a contiguous array of string pointers whose size is given by the "n" parameter. Returns a value greater than zero if the addition completed successfully, a negative error code otherwise.  If n is zero nothing is done and no errors are issued, even if the array pointer or the data pointer are\Null.
\apierrors
\doerror{BADARG} The StringCollection pointer or the data pointers are\Null.
\doerror{READONLY} The list is read-only. No modifications allowed.
\doerror{NOMEMORY} Not enough memory to complete the operation.
\returns
A positive number if the operation completed, negative error code otherwise.
\example
    StringCollection *SC;
    char *data[] = { “One”,”two,”three”};
    int result = iStringCollection.AddRange(SC,3,data);
    if (result < 0) { /* Error handling */ }
\end{verbatim}

\api{CastToArray}
        Vector *(*CastToArray)(StringCollection *SC);
\end{verbatim}
\apidescription
Converts a string collection into an vector.
\apierrors
\doerror{BADARG} The StringCollection pointer is\Null.
\doerror{NOMEMORY} Not enough memory to complete the operation.
\returns
A positive number if the operation completed, negative error code otherwise.

\api{CreateFromFile}
 StringCollection *(*CreateFromFile)(unsigned char *fileName);
\end{verbatim}
\apidescription
Reads the given text file and stores each line in a string of the collection. The end of line characters are discarded.
\apierrors
\doerror{BADARG} The fileName pointer is\Null.
\doerror{NOMEMORY} Not enough memory to complete the operation.
\doerror{NOENT} The file doesn't exist or can't be opened for reading.
\returns
A pointer to a new string collection with the contents of the file. If an error occurs the result is\Null and the current error function (in the iError interface) is called.1

\api{FindFirstText}
    size_t (*FindFirstText)(StringCollection *SC,char *text);
\end{verbatim}
 \apidescription
Finds the first occurrence of the given text in the string collection. 
\apierrors
\doerror{BADARG} One or both arguments are\Null.
\returns
The zero based index of the line that contains the given text or the constant \textsc{CONTAINER\_ERROR\_NOTFOUND} if the text is not found.

\api{FindNextText}
    size_t (*FindNextText)(StringCollection *SC,char *txt,size_t start);
\end{verbatim}
\apidescription
Starts searching for the given text at the specified line.
\apierrors
\doerror{BADARG} The StringCollection or the text pointer are\Null.
\returns
The one based index of the line that contains the text or zero if the text is not found or an error occurred.

\api{FindTextPositions}
    Vector *(*FindTextPositions)(StringCollection *SC,char *text);
\end{verbatim}
\apidescription
Searches all occurrences of the given text in the given string collection.
\apierrors
\doerror{BADARG} The StringCollection or the text pointer are\Null.
\doerror{NOMEMORY} Not enough storage for holding the result array list.
\returns
An array list containing a pair of integers for each occurrence containing the zero based position of the line where the text was found and a second number indicating the character index within the line where the searched text occurs.
The result is\Null if there wasn't any occurrences of the searched text in the string collection or an error was detected.

\api{InsertIn}
int (*InsertIn)(StringCollection *dst, size_t pos, 
                StringCollection *newData);
\end{verbatim}
\apidescription
 Inserts the given StringCollection into the destination StringCollection at the given position. If the position is greater than the actual length of the string collection the new data will be inserted at the end.
 \apierrors
 \doerror{BADARG} The source or destination pointers are\Null.
 \doerror{READONLY} The destination is read only.
\example
#include <containers.h>
static void PrintStringCollection(StringCollection *AL)
{
    size_t i;
    printf("Count %ld, Capacity %ld\n",
           (long)iStringCollection.Size(AL),
           (long)iStringCollection.GetCapacity(AL));
    for (i=0; i<iStringCollection.Size(AL);i++) {
        printf("%s ",iStringCollection.GetElement(AL,i));
    }
    printf("\n");
}

static void FillStringCollection(StringCollection * AL,int start)
{
    size_t i;
    char buf[256];

    for (i=0; i<10;i++) {
        double d = i+start;
        sprintf(buf,"%g",d);
        iStringCollection.Add(AL,buf);
    }
}
int main(void)
{
    StringCollection *AL = iStringCollection.Create(10);
    StringCollection *AL1 =iStringCollection.Create(10);
    FillStringCollection(AL,0);
    FillStringCollection(AL1,100);
    iStringCollection.InsertIn(AL,5,AL1);
    PrintStringCollection(AL);
    return 0;
}
\end{verbatim}
The example creates two string collections, fills them with the string representation of the numbers from 0 to 9 and from 100 to 109, then inserts the second collection into the first one at position 5.
\par\noindent
OUTPUT:
\begin{verbatim}
Count 20, Capacity 20
0 1 2 3 4 100 101 102 103 104 105 106 107 108 109 5 6 7 8 9
\end{verbatim}
\api{Mismatch}
int (*Mismatch)(const StringCollection *a1,
                const StringCollection *a2,
                           size_t *mismatch);
\end{verbatim}
\apidescription
Returns the index of the first element that is different when comparing both collections in the passed pointer \textsl{mismatch}. If one  is shorter than the other the comparison stops
when the last element from the shorter array is compared. The comparison also stops when the first difference is spotted.
\apierrors
\doerror{BADARG} Any of the arguments is\Null.
\returns
If a mismatch is found the result is greater than zero and the \textsl{mismatch} argument will contain the index of the first element that compared 
unequal. This will be always the case for arrays of different length.

If both arrays are the same length and no differences are found the result is zero and the value pointed to by the 
\textsl{mismatch} argument is one more than the length of the arrays.

If an error occurs, a negative error code is returned. The \textsl{mismatch} argument contains zero.
\example
#include "containers.h"
char *table[] = {"String 1", "String 2","String 3","String 4",};

int main(void)
{
    size_t idx;
    StringCollection *sc = iStringCollection.Create(4);
    StringCollection *sc2;
    iStringCollection.AddRange(sc,sizeof(table)/sizeof(table[0]),table);
    sc2 = iStringCollection.Copy(sc);
    iStringCollection.ReplaceAt(sc,2,"String456");
    iStringCollection.Mismatch(sc,sc2,&idx);
    printf("String collections differ at position %d\n",idx);
}
OUTPUT:
String collections differ at position 2
\end{verbatim}
\api{PopBack}
 size_t (*PopBack)(StringCollection *SC,char *buffer,size_t buflen);
\end{verbatim}
\apidescription
If the string collection is not empty, it will copy at most buflen characters into the given buffer. If the buffer pointer is\Null or the length of the buffer is zero it will return the length of the element that would be popped.
\apierrors
\doerror{BADARG} The StringCollection pointer is\Null.
\returns
Zero if there was an error or the string collection is empty. Otherwise returns the length of the string stored at the position to pop, including the 
terminating zero. 

\api{WriteToFile}
    int (*WriteToFile)(StringCollection *SC,unsigned char *fileName);
\end{verbatim}
\apidescription
Writes the contents of the given string collection into a file with the given name. If the collection is empty an empty file is created. The resulting file contains a line for each string in the collection.
\apierrors
\doerror{BADARG} The StringCollection pointer or the fileName are\Null.
\returns
A positive number if the operation completes, or a negative error code otherwise. If the collection is empty the result is zero.
%--------------------------------------------------------------------------------------------------------------------------
%                                                   DICTIONARY
%--------------------------------------------------------------------------------------------------------------------------
\newpage
\section{The dictionary container iDictionary}
A dictionary is an associative container that associates a text key with a piece of data. It can be implemented by means of a hash table that uses a hash function to map the key into a restricted integer range, used in a table.
\subsection{The dictionary interface}
\index{iDictionary}
\begin{verbatim}
typedef struct _Dictionary Dictionary;

typedef struct {
    int (*Add)(Dictionary *Dict,
               const unsigned char *key,void *Data);
    int (*Apply)(Dictionary *Dict,
                  int (*Applyfn)(const unsigned char *Key,
                                 const void *data,void *arg),
                  void *arg);
    Vector *(*CastToArray)(Dictionary *);
    int (*Clear)(Dictionary *Dict);
    Dictionary *(*Copy)(Dictionary *dict);
    Dictionary *(*Create)(size_t ElementSize,size_t hint);
    Dictionary *(*CreateWithAllocator)(size_t elementsize,size_t hint,
                                     ContainerMemoryManager *allocator);
    int (*deleteIterator)(Iterator *);
    int (*Equal)(Dictionary *dict1,Dictionary *dict2);
    int (*Erase)(Dictionary *Dict,const unsigned char *);
    int (*Finalize)(Dictionary *Dict);
    size_t (*GetElementSize)(Dictionary *d);
    ContainerMemoryManager *(*GetAllocator)(Dictionary *Dict);
    const void *(*GetElement)(const Dictionary *Dict,
                             const unsigned char *Key);
    unsigned (*GetFlags)(Dictionary *Dict);
    StringCollection *(*GetKeys)(Dictionary *Dict);
    Dictionary *(*Init)(Dictionary *Dict,size_t elemsize,size_t hint);
    Dictionary *(*InitWithAllocator)(Dictionary *Dict,
                        size_t elementsize, size_t hint,
                              ContainerMemoryManager *allocator);
    int (*Insert)(Dictionary *d,const unsigned char *key,void *Data);
     int (*InsertIn)(Dictionary *dst,Dictionary *src);
    Dictionary * (*Load)(FILE *stream, ReadFunction readFn, void *arg);
    Iterator *(*newIterator)(Dictionary *dict);
    int (*Save)(Dictionary *Dict, FILE *stream, 
                SaveFunction Fn, void *arg);
    ErrorFunction (*SetErrorFunction)(Dictionary *Dict,ErrorFunction f);
    unsigned (*SetFlags)(Dictionary *Dict,unsigned flags);
    size_t (*Size)(Dictionary *Dict);
    size_t (*Sizeof)(Dictionary *dict);
} DictionaryInterface;
\end{verbatim}
\subsection{The API}
\api{Add}
    int (*Add)(Dictionary *Dict,char *key,void *data);
\end{verbatim}
\apidescription
Adds the given element to the container using the given “key” string. It is assumed that “data” points to a contiguous memory area of at least ElementSize bytes.  Both the key and the data are copied into the container.

If an element exists with the given key, its contents are replaced with the new data. For a different behavior use \texttt{Insert} or \texttt{Replace}.

\apierrors
\doerror{BADARG} The dictionary, the key or the data pointers are\Null.
\doerror{READONLY} The dictionary is read-only. No modifications allowed.
\doerror{NOMEMORY} Not enough memory to complete the operation.
\returns
A positive number if the operation added a new element, zero if the data was written into an existing element, or a negative error code if an error occurred.
\example
    Dictionary *dict;
    double data = 4.5;
    int result = iDictionary.Add(dict,”Interest rate”,&data);
    if (result < 0) { /* Error handling */ }
\end{verbatim}

\api{Apply}
    int (*Apply)(Dictionary *Dict,
                  int (Applyfn)(const unsigned char *key,
                                void *data,
                                void *extraArg),
                  void *extraArg);
\end{verbatim}
\apidescription
Will call the given function for each element of the array. The first argument of the callback function receives they key ,the second is a pointer to the element of the Dictionary. The  third argument of the callback is the “extraArg” argument that the Apply function receives and passes to  the callback. This way some context can be passed to the callback, and from one element to the next.
Note that the result of the callback is not used. This allows all kinds of result types to be accepted after a suitable function type cast.
If the dictionary is read-only, a copy of the element will be passed to the callback function.

\apierrors
\doerror{BADARG}  Either the dictionary pointer or Applyfn are\Null.
\doerror{NOMEMORY} The dictionary is read-only and there is no more memory to allocate the buffer to copy each element.
\example
    static int print(const char *key,
                      void *pElement,
                      void *pResult)
    {
        double *p = pElement;
        printf("%s: %g\n”,key,*p);
        return 1;
    }
    int main(void) {
        Dictionary *dict = iDictionary.Create(sizeof(double),5);
        double d = 2;
        iDictionary.Add(dict,”First item”,&d);
        d = 3;
        iDictionary.Add(dict,”Second item”,&d);
        iDictionary.Apply(dict,print,NULL);
        return 0;
    }
\end{verbatim}

Output should be:
\begin{verbatim}
First item: 2
Second item: 3
\end{verbatim}

\api{Clear}
    int (*Clear)(Dictionary *dict);
\end{verbatim}
\apidescription
Erases all stored data and releases the memory associated with it. The dictionary header is not destroyed, and its contents will be the same as when it was initially created. It is an error to use this function when there are still active iterators for the container.
\returns
The result is greater than zero if successful, or an error code if an error occurs. 
\apierrors
\doerror{BADARG} The vector pointer is\Null.
\doerror{READONLY} The vector is read only.
\example
    Dictionary *Dict;
    int m = iDictionary.Clear(Dict);
\end{verbatim}

\api{Contains}
    int (*Contains)(Dictionary *Dict,const unsigned char *Key);
\end{verbatim}
\apidescription
Returns one if the given key is stored in the dictionary, zero otherwise.  If an error occurs it returns a negative error code.
\apierrors
\doerror{BADARG} Either Dict or Key are\Null.
\example
    Dictionary *dict;
    int r = iDictionary.Contains(dict,”Item 1”);
\end{verbatim}
\api{Copy}
    Dictionary *(*Copy)(Dictionary *Dict);
\end{verbatim}
\apidescription
A shallow copy of the given dictionary is performed. Only ElementSize bytes will be copied for each element. If the element contains pointers, only the pointers are copied, not the objects they point to. The new memory will be allocated using the given list's allocator.

\apierrors
\doerror{NOMEMORY} There is not enough memory to complete the operation.
\doerror{BADARG} The given vector pointer is\Null.

\example
    Dictionary *newDict,*Old;
    newDict = iDictionary.Copy(Old);
\end{verbatim}
\api{Create}
    Dictionary *(*Create)(size_t ElementSize,size_t hint);
    Dictionary *(*CreateWithAllocator)(size_t elementsize,size_t hint,
                                     ContainerMemoryManager *allocator);
\end{verbatim}
\index{CreateWithAllocator}
\apidescription
Creates a new dictionary with the given element size and with a table big enough to store \texttt{hint} entries. The \texttt{Create} function
uses the current memory manager as the allocator for the new dictionary. \texttt{CreateWithAllocator} uses the given allocator object.
\apierrors
\doerror{NOMEMORY} Not enough memory to complete the operation.
\returns A pointer to the new dictionary or\Null if there is not enough memory to create it.
\api{deleteIterator}
    int deleteIterator(Iterator *it);
\end{verbatim}
\apidescription
Reclaims the memory used by the given iterator object
\returns 
Integer smaller than zero with error code or a positive number when the operation completes.
\apierrors
\doerror{BADARG} The iterator pointer is\Null.

\api{Equal}
    int (*Equal)(Dictionary *d1,Dictionary *d2);
\end{verbatim}
\apidescription
Compares the given dictionaries using their comparison function. If the dictionaries differ in their size, flags, or hash functions they compare unequal. If any of their elements differ, they compare unequal.
If both d1 and d2 are\Null they compare equal. If Both d1 and d2 are empty they compare equal.
\apierrors
None
\returns
The result is one if the dictionaries are equal, zero otherwise.

\api{Erase}
    int (*Erase)(Dictionary *Dict,const char *key);
\end{verbatim}
\apidescription
Removes from the dictionary the element that matches the given key.

\returns
A positive value that indicates that a match was found and the element was removed. If no element matched the result is CONTAINER\_ERROR\_NOTFOUND. If an error occurs, a negative error code is returned.
\apierrors
\doerror{BADARG} One or both arguments are\Null.

\example
    double d = 2.3;
    Vector *AL;
    int r = iVector.Erase(AL,&d);
    if (r > 0)
        printf("2.3 erased|n”);
    else if (r == 0)
        printf("No element with value 2.3 present\n”);
    else
        printf("error code %d\n”,r);
\end{verbatim}

\api{Finalize}
    int (*Finalize)(Dictionary *dict);
\end{verbatim}
\apidescription
Reclaims all memory used by the dictionary, including the array header object itself.
\apierrors
\doerror{BADARG} The given pointer is\Null.
\doerror{READONLY} The dictionary is read-only. No modifications allowed.
\returns
A positive value means the operation completed. A negative error code indicates failure.
\example
    Dictionary *AL;
    int r = iDictionary.Finalize(AL);
    if (r < 0) { /* error handling */ }
\end{verbatim}

\api{GetElementSize}
    size_t (*GetElementSize)(Dictionary *Dict);
\end{verbatim}
\apidescription
Retrieves the size of the elements stored in the given dictionary. Note that this value can be different than the value given to the creation function because of alignment requirements.
\apierrors
\doerror{BADARG} The given pointer is\Null.

\returns
The element size or zero if an error.

\example
    Dictionary *Dict;
    size_t siz = iDictionary.GetElementSize(Dict);
\end{verbatim}

\api{GetElement}
void *(*GetElement)(Dictionary *Dict,const unsigned char *key);
\end{verbatim}
\apidescription
\returns a read only pointer to the element at the given index, or\Null if the operation failed.  This function will return\Null if the dictionary is read only.
 
Use the CopyElement function to get a read/write copy of an element of the dictionary.

\apierrors
\doerror{BADARG}    The given array pointer or the key are\Null.
\doerror{READONLY}    The array is read only.
\example
    Dictionary *Dict;
    double *d = iDictionary.GetElement(Dict,”Index”);
    if (d == NULL) { /* Error handling */ }
\end{verbatim}
\api{Init}
	Dictionary *(*Init)(Dictionary *Dict,size_t elementsize,size_t hint);
\end{verbatim}
\apidescription
Initializes the indicated storage for use asa dictionary object. This procedure is completely equivalent to \texttt{Create} with the difference
that there is no allocation done for the dictionary header. Uses the current memory manager for the allocations of the slot table.
\returns
A pointer to its first argument if successfull or\Null if there is no memory to complete the operation.
\api{InitWithAllocator}
    	Dictionary *(*InitWithAllocator)(Dictionary *Dict,
                        size_t elementsize, size_t hint,
                              ContainerMemoryManager *allocator);
\end{verbatim}
\apidescription
Initializes the indicated storage for use as a dictionary object. This procedure is completely equivalent to \texttt{CreateWithAllocator} with the difference
that there is no allocation done for the dictionary header. Uses the given memory manager for the allocations of the slot table.
\returns
A pointer to its first argument if successfull or\Null if there is no memory to complete the operation.

\api{Insert}
int (*Insert)(Dictionary *Dict, const unsigned char *key,void *Data);
\end{verbatim}
\apidescription
Inserts the new key and its corresponding data into the given dictionary. If the key is already present, nothing is changed. This contrasts with the behavior of \texttt{Add} that will replace an existing key.
\apierrors
\doerror{BADARG} Any of the given pointers is\Null.
\doerror{READONLY}    The array is read only.
\doerror{NOMEMORY} Not enough memory to complete the operation.
\returns A positive value if the key was inserted, zero if the key was already present, or a negative error code.
\api{Load}
 Dictionary *(*Load)(FILE *stream,ReadFunction readFn,void *arg);
\end{verbatim}
\apidescription
Reads a dictionary previously saved with the Save function from the stream pointed to by stream. If readFn is not\Null, it will be used to read each element. The “arg” argument will be passed to the read function. If the read function is\Null, this argument is ignored and a default read function is used.
\apierrors
\doerror{BADARG} The given stream pointer is\Null.
\doerror{NOMEMORY} There is not enough memory to complete the operation.
\returns
A new dictionary or\Null if the operation could not be completed. Note that the function pointers in the array are NOT saved, nor any special allocator that was in the original dictionary. Those values will be the values by default. To rebuild the original state the user should replace the pointers again in the new array.

\api{newIterator}
    Iterator *(*newIterator)(Dictionary *Dict);
\end{verbatim}
\apidescription
Allocates and initializes a new iterator object to iterate this dictionary. The exact sequence is implementation defined but it will be the same for the same dictionary with the same number of elements.
\apierrors
If no more memory is available it returns\Null.
\returns
A pointer to a new iterator or\Null if there is no more memory left.
\example
    Dictionary *Dict;
    Iterator *it = iDictionary.newIterator(Dict);
    double *d;
    for (d=it->GetFirst(it); d != NULL; d = it->GetNext(it)) {
        double val = *d;
        // Work with the value here
    }
    iDictionary.deleteIterator(it);
\end{verbatim}

\api{Size}
    size_t (*Size)(Dictionary *Dict);
\end{verbatim}
\apidescription
Returns the number of elements stored in the dictionary or \textsc{SIZE\_MAX} if the dictionary pointer is\Null.

\apierrors
\doerror{BADARG}    The given array pointer or the key are\Null.
\example
    Dictionary *Dict;
    size_t elem = iDictionary.Size(Dict);
\end{verbatim}

\api{Save}
int (*Save)(Dictionary *D, FILE *out, SaveFunction Fn, void *arg);
\end{verbatim}
\apidescription
The contents of the given dictionary are saved into the given stream. If the save function pointer is not\Null, it will be used to save the contents of each element and will receive the arg argument passed to Save, together with the output stream. Otherwise a default save function will be used and arg will be ignored.
The output stream must be opened for writing and must be in binary mode.
\apierrors
\doerror{BADARG} The dictionary pointer or the stream pointer are\Null.
EOF A disk input/output error occurred.

\returns
A positive value if the operation completed, a negative value or EOF otherwise.

\example
    Dictionary *Dict;
    FILE *outFile;
    if (iDictionary.Save(Dict,outFile,NULL,NULL) < 0) { 
        /* Handle error here */
    }
\end{verbatim}

\api{Sizeof}
    size_t (*Sizeof)(Dictionary *Dict);
\end{verbatim}
\apidescription
Returns the total size in bytes of the dictionary, including the header, and all data stored in the dictionary, including the size of the dictionary header.
If Dict is\Null, the result is the size of the \texttt{Dictionary} structure.
\returns
The number of bytes used by the dictionary or the size of the Dictionary structure if the argument is\Null.
\example
    Dictionary *Dict;
    size_t  size = iDictionary.Sizeof(Dict);
\end{verbatim}

\api{SetErrorFunction}
ErrorFunction (*SetErrorFunction)(Dictionary *dict,ErrorFunction efn); 
\end{verbatim}
\apidescription
Replaces the current error function  for the given dictionary with the new error function if different from\Null.
\apierrors
\doerror{BADARG} The dictionary pointer is\Null.
\doerror{READONLY} The dictionary is read only and the function argument is not\Null.
\returns
The old value of the error function or\Null if there is an error.

\api{Size}
    size_t (*Size)(Dictionary *d);
\end{verbatim}
\apidescription
Returns the number of elements stored in the dictionary. If the argument is\Null the result is zero.
\example
    Dictionary *d;
    size_t elem = iDictionary.Size(d);
\end{verbatim}

%--------------------------------------------------------------------------------------------------------------------------
%                                                   HASHTABLE
%--------------------------------------------------------------------------------------------------------------------------
\newpage
\section{Hash Table: iHashTable}
Hash table is a similar container as dictionary, but allows for more features at the expense of a slightly more complicated interface. 
Keys aren't restricted to zero terminated strings but can be any kind of data. 
The table resizes itself as it grows.
Merging two hash tables

\subsection{The interface}
\index{iHashTable}
\begin{verbatim}
typedef struct {
    int (*Add)(HashTable *HT,const void *key,
               size_t keyLength,const void *Data);
    int (*Apply)(HashTable *HT,
                  int (*ApplyFn)(void *Key,
                                 size_t keyLength,
                                 void *data,
                                 void *ExtraArg),
                  void *ExtraArg);
    int (*Clear)(HashTable *HT);
    HashTable *(*Copy)(const HashTable *Orig,Pool *pool);
    HashTable *(*Create)(size_t ElementSize);
    int (*deleteIterator)(Iterator *);
    int (*Erase)(HashTable *HT,void *key,size_t klen);
    int (*Finalize)(HashTable *HT);
    void *(*GetElement)(const HashTable *HT,
                        const void *Key ,size_t keyLength);
    unsigned (*GetFlags)(const HashTable *HT);
    HashTable *(*Load)(FILE *stream, ReadFunction readFn, void *arg);
    HashTable *(*Merge)(Pool *p, 
                        const HashTable *overlay, 
                        const HashTable *base,
                        void * (*merger)(Pool *p,
                                         const void *key,
                                         size_t keyLength,
                                         const void *h1_val,
                                         const void *h2_val,
                                         const void *data),
                        const void *data);
    Iterator *(*newIterator)(HashTable *);
    HashTable *(*Overlay)(Pool *p, 
                          const HashTable *overlay, 
                          const HashTable *base);
    int (*Resize)(HashTable *HT,size_t newSize);
    int  (*Replace)(HashTable *HT,
                    const void *key,
                    size_t keyLength,const void *data);
    int (*Save)(HashTable *HT,
                FILE *stream, SaveFunction saveFn,void *arg);
    int (*Search)(HashTable *ht,
                  int (*Comparefn)(void *rec, 
                                   const void *key,
                                   size_t keyLength,
                                   const void *value), 
                  void *rec);
    ErrorFunction (*SetErrorFunction)(HashTable *HT,ErrorFunction fn);
    unsigned (*SetFlags)(HashTable *HT,unsigned flags);
    HashFunction (*SetHashFunction)(HashTable *ht, HashFunction hf);
    size_t (*Size)(const HashTable *HT);
    size_t (*Sizeof)(const HashTable *HT);
} HashTableInterface;
extern HashTableInterface iHashTable;
\end{verbatim}
\subsection{The API}
\api{Add}
int (*Add)(HashTable *ht,
           void *key,
           size_t keyLength,
           const void *data);
\end{verbatim}
\apidescription
Adds the given element to the container using the given “key” string. It is assumed that “data” points to a contiguous memory area of at least ht->ElementSize bytes.  Both the key and the data are copied into the container.

If an element exists with the given key, its contents are replaced with the new data.
\apierrors
\doerror{BADARG} The hash table, the key or the data pointers are\Null.
\doerror{READONLY}: The hash table is read-only. No modifications allowed.
\doerror{NOMEMORY} Not enough memory to complete the operation.
\returns
A positive number if the operation added a new element, zero if the data was written into an existing element, or a negative error code if an error occurred.

\example
    HashTable *ht;
    double data = 4.5;
    int result = iHashTable.Add(ht,”Interest rate”,
                                  strlen(“Interest rate”),&data);
    if (result < 0) { /* Error handling */ }
\end{verbatim}

\api{Apply}
    int (*Apply)(HashTable *ht,
                  int (Applyfn)(const unsigned char *key,
                                size_t keyLength,
                                void *data,
                                void *extraArg),
                  void *extraArg);
\end{verbatim}
\apidescription
Apply will call the given function for each element of the array. The first argument of the callback function receives they key ,the second is the length of the key. The third is a pointer to one element of the table. The fourth argument of the callback is the “extraArg” argument that the Apply function receives and passes to the callback. This way some context can be passed to the callback, and from one element to the next.

Note that the result of the callback is not used. This allows all kinds of result types to be accepted after a suitable function type cast.

If the dictionary is read-only, a copy of the element will be passed to the callback function.
\apierrors
\doerror{BADARG}  Either the hash table pointer or Applyfn are\Null.
\doerror{NOMEMORY} The hash table is read-only and there is no more memory to allocate the buffer to copy each element.
\example
    static int print(const char *key,
                      void *pElement,
                      void *pResult)
    {
        double *p = pElement;
        printf("%s: %g\n”,key,*p);
        return 1;
    }
    int main(void) {
        Dictionary *dict = iDictionary.Create(sizeof(double),5);
        double d = 2;
        iDictionary.Add(dict,”First item”,&d);
        d = 3;
        iDictionary.Add(dict,”Second item”,&d);
        iDictionary.Apply(dict,print,NULL);
        return 0;
    }
Output should be:
First item: 2
Second item: 3
\end{verbatim}

\api{Clear}
    int (*Clear)(HashTable *ht);
\end{verbatim}
\apidescription
Erases all stored data and releases the memory associated with it. The hash table header is not destroyed, and its contents will be the same as it was when initially created. It is an error to use this function when there are still active iterators for the container.
\returns
The result is greater than zero if successful, or an error code if an error occurs. 
\apierrors
\doerror{BADARG} The hash table pointer is\Null.
\doerror{READONLY} The hash table is read only.
\example
    HashTable *ht;
    int m = iHashTable.Clear(ht);
\end{verbatim}

\api{Copy}
    HashTable *(*Copy)(const HashTable *Orig,Pool *pool);
\end{verbatim}
\apidescription
Copies the given hash table using the given pool. If “pool” is\Null,the pool of the given hash table will be used.
\apierrors
\doerror{BADARG} The hash table pointer is\Null.
\doerror{NOMEMORY} Not enough memory to complete the operation.

\api{Create}
    HashTable *(*Create)(size_t ElementSize);
\end{verbatim}
\apidescription
Creates a new hash table and initializes all fields. The table will use the current memory manager for its pool.
\apierrors
\doerror{BADARG} The parameter is zero or bigger than the maximum size the implementation supports.
\doerror{NOMEMORY} Not enough memory to complete the operation.

\api{deleteIterator}
    int (*deleteIterator)(Iterator *);
\end{verbatim}
\apidescription
Releases the memory used by the given iterator.
\apierrors
\doerror{BADARG} The parameter is\Null.
\returns A positive value if successful or a negative error code.
\api{Erase}
    int (*Erase)(HashTable *HT,void *key,size_t keyLength);
\end{verbatim}
\apidescription
Removes from the hash table the element with the given key.
\apierrors
\doerror{BADARG} The hash table parameter or the key pointer are\Null, or the keyLength is zero.
\returns
A positive number if the operation completed, a negative error code otherwise.

Finalize
Synopsis:
    int (*Finalize)(HashTable *HT);
Description:
Releases all memory used by the hash table and destroys the hash table header itself.
\apierrors
\doerror{BADARG} The parameter is\Null.

\api{GetElement}
void *(*GetElement)(const HashTable *H,const void *Key,size_t keyLen);
\end{verbatim}
\apidescription
Returns a pointer to the given hash table element. 
\apierrors
\doerror{BADARG} The hash table parameter or the key pointer are\Null, or the keyLen parameter is zero.
\returns
A pointer to the element or\Null if no element with the specified key exists.

\api{GetFlags}
    unsigned (*GetFlags)(const HashTable *HT);
\end{verbatim}
\apidescription
Returns an unsigned integer with the state of the table.

\api{Load}
 HashTable *(*Load)(FILE *stream,ReadFunction readFn,void *arg);
\end{verbatim}
\apidescription
Reads a table previously saved with the Save function from the stream pointed to by stream. If readFn is not\Null, it will be used to read each element. The “arg” argument will be passed to the read function. If the read function is\Null, this argument is ignored and a default read function is used.
\apierrors
\doerror{BADARG} The given stream pointer is\Null.
\doerror{NOMEMORY} There is not enough memory to complete the operation.
\returns
A new table or\Null if the operation could not be completed. Note that the function pointers in the array are NOT saved in most implementations, nor any special allocator that was in the original table. In most implementations those values will be the values by default. To rebuild the original state the user should replace the pointers again in the new table.

\api{Merge}
    HashTable *(*Merge)(Pool *p, 
                        const HashTable *overlay, 
                        const HashTable *base,
                        void * (*merger)(Pool *p,
                                         const void *key,
                                         size_t keyLength,
                                         const void *h1_val,
                                         const void *h2_val,
                                         const void *data),
                        const void *data);
\end{verbatim}
\apidescription
Merge two hash tables into one new hash table. If the same key is present in both tables, call the supplied merge function to produce a merged value for the key in the new table. Both hash tables must use the same hash function. 
The arguments should be:
\begin{enumerate}
\item
The pool to use when allocating memory. If\Null, the pool of the “base” hash table will be used.
\item
The first table to be used in the merge.
\item
The second table
\item
An argument to pass to the merger function.
\end{enumerate}

\api{newIterator}
    Iterator *(*newIterator)(HashTable *HT);
\end{verbatim}
\apidescription
Allocates and initializes a new iterator object to iterate this table. The exact sequence of each object returned is implementation defined but it will be the same for the same dictionary with the same number of elements.
\apierrors
\doerror{BADARG} The parameter is\Null.
\doerror{NOMEMORY} Not enough memory to complete the operation.
\returns
A pointer to a new iterator or\Null if the operation couldn't be completed.
\example
    HashTable *HT;
    Iterator *it = iHashTable.newIterator(HT);
    double *d;
    for (d=it->GetFirst(it); d != NULL; d = it->GetNext(it)) {
        double val = *d;
        // Work with the value here
    }
    iHashTable.deleteIterator(it);
\end{verbatim}

\api{Overlay}
    HashTable *(*Overlay)(Pool *p, 
                          const HashTable *overlay, 
                          const HashTable *base);
\end{verbatim}
\apidescription
Copies overlay into base. If conflicts arise, the data in base will be copied in the result.
\apierrors
\doerror{BADARG} One of the arguments is\Null.
\doerror{NOMEMORY} Not enough memory to complete the operation.


\api{Resize}
    int (*Resize)(HashTable *HT,size_t newSize);
\end{verbatim}
\apidescription
Will resize the given hash table to a new size. If the given new size is zero, the new size is implementation defined, and equal to the amount when automatic resizing occurs.
\apierrors
\doerror{BADARG} The parameter is\Null.
\doerror{NOMEMORY} Not enough memory to complete the operation.
\returns
A positive value if the operation completed, a negative error code otherwise.

\api{Replace}
    int  (*Replace)(HashTable *HT, const void *key,
                    size_t keyLength,const void *data);
\end{verbatim}
\apidescription
Will replace the contents of the given element if found.
\apierrors
\doerror{BADARG} The hash table pointer, the key or the replacement data are\Null, or the keyLength is zero.
\returns
A positive number if the element was replaced or zero if the element wasn't found. If the operation didn't complete a negative error code is returned.

\api{Save}
int (*Save)(HashTable *HT, FILE *out, SaveFunction Fn, void *arg);
\end{verbatim}
\apidescription
The contents of the given table are saved into the given stream. If the save function pointer is not\Null, it will be used to save the contents of each element and will receive the arg argument passed to Save, together with the output stream. Otherwise a default save function will be used and arg will be ignored.
The output stream must be opened for writing and must be in binary mode.
\apierrors
\doerror{BADARG} The array pointer or the stream pointer are\Null.
\par\noindent 
EOF A disk input/output error occurred.

\returns
A positive value if the operation completed, a negative value or EOF otherwise.
\example
    HashTable *HT;
    FILE *outFile;
    if (iHashTable.Save(HT,outFile,NULL,NULL) < 0) { 
        /* Handle error here */
    }
\end{verbatim}

\api{SetErrorFunction}
ErrorFunction (*SetErrorFunction)(HashTable *HT,ErrorFunction fn); 
\end{verbatim}
\apidescription
Replaces the current error function  for the given table with the new error function if the parameter is different from\Null. Otherwise no replacement is done.
\apierrors
\doerror{BADARG} The table pointer is\Null.
\doerror{READONLY} The table is read only and the function argument is not\Null.
\returns
The old value of the error function or\Null if there is an error.

\api{Size}
   size_t (*Size)(const HashTable *HT);
\end{verbatim}
\apidescription
Returns the number of elements stored in the given table.
\apierrors
\doerror{BADARG} The table pointer is\Null.
\returns
The number of elements stored in the table

\api{Sizeof}
   size_t (*Sizeof)(const HashTable *HT);
\end{verbatim}
\apidescription
Returns the number of bytes of storage used in the given table including the size of the elements stored in it.
If HT is\Null the result is the size of the HashTable header.
\returns
The number of elements stored in the table or the size of the HashTable header if the HT pointer is\Null.

%--------------------------------------------------------------------------------------------------------------------------
%                                                   QUEUES
%--------------------------------------------------------------------------------------------------------------------------
\newpage
\section{Queues: iQueue}
Queues are a type of container adaptors, specifically designed to operate in a FIFO context (first-in first-out), where elements are inserted into one end of the container and extracted from the other.

The sample implementation shows how to implement this container as an “adaptor” container, i.e. based on another container. The implementation uses a linked list to implement a queue.
\subsection{Interface}
\begin{verbatim}
typedef struct _Queue Queue;

typedef struct _QueueInterface {
    Queue   *(*Create)(size_t elementSize);
    Queue   *(*CreateWithAllocator)(size_t elementSize,
                           ContainerMemoryManager *allocator);
    int      (*Size)(Queue *Q);
    size_t   (*Sizeof)(Queue *q);
    int      (*Enqueue)(Queue *Q, void *Element);
    void    *(*Dequeue)(Queue *Q);
    int      (*Clear)(Queue *Q);
    int      (*Finalize)(Queue *Q);
    void *   (*Front)(Queue *Q);
    void *   (*Back)(Queue *Q);
    List *   (*GetList)(Queue *q);
    
} QueueInterface;

extern QueueInterface iQueue;
\end{verbatim}
\subsection{The API}
All methods are exactly like the ones in other containers except for Enqueue, that is equivalent to “Add” since adds one element at the end of the container, and Dequeue, that is the same as PopFront, i.e. pops the first element of the container.
\api{Front}
    int   (*Front)(Queue *Q,void *result);
\end{verbatim}
\apidescription
Returns the contents of the first element in the given memory area that should be at least the size of the element size of the queue. Note that nothing is changed, and the first element is not erased from the container.
\returns
A positive number for success, zero if the queue is empty or a negative error code.
\apierrors
\doerror{BADARG} The Queue pointer is\Null.
\api{Back}
    int   (*Back)(Queue *Q,void *result);
\end{verbatim}
\apidescription
Returns the contents of the last element in the given memory area that should be at least the size of the element size of the queue. Note that nothing is changed, and the last element is not erased from the container.
\returns
A positive number for success, zero if the queue is empty or a negative error code.
\apierrors
\doerror{BADARG} The Queue pointer is\Null.
\api{GetList}
List *(*GetList)(Queue *q);
\end{verbatim}
\apidescription
Queues are based on the list container. It is not necessary to duplicate all the list functions in the queue interface: this function allows you to access the underlying list and use all the list specific APIs with it.
\returns
A pointer to the list container or\Null if the queue pointer passed is\Null.

%--------------------------------------------------------------------------------------------------------------------------
%                                                   DEQUE
%--------------------------------------------------------------------------------------------------------------------------
\section{Deque: iDeque}
Deque (usually pronounced like "deck") is an irregular acronym of double-ended queue. Double-ended queues are a kind of sequence containers. As such, their elements are ordered following a strict linear sequence.
Deques may be implemented by specific libraries in different ways, but in all cases they allow for adding and retrieving elements at both ends, with storage always handled automatically (expanding and contracting as needed). 

Operations to insert and retrieve elements in the middle are not provided because if users need a plain sequential container they can use one. Individual implementation can offer those if they think it is useful. This differs from the C++ implementation.

Here is a little table with a Rosetta stone for deque:
\par
\noindent
{\footnotesize
\begin{tabular} {l l l l l l l l l}
C & Ada & C++ & Java & Perl & PHP & Python 
\\
\hline
\\
PushBack & Append & push\_back & offerLast & push & array\_push & append 
\\
PushFront & Prepend & push\_front & offerFirst & unshift & array\_unshift & appendleft 
\\
PopBack & Delete\_Last & pop\_back & pollLast & pop & array\_pop & pop 
\\
PopFront & Delete\_First & pop\_front & pollFirst & shift & array\_shift & popleft 
\\
Back & Last\_Element & back & peekLast & \$array[-1] & end & $<$obj$>$[-1]  
\end{tabular}
}
\par
Some functions that the C$++$ interface provides like is\_empty() can be obtained in this implementation simply by invoking:
\begin{verbatim}
iDeque.Size(deque) == 0
\end{verbatim}
\subsection{Interface}
The interface iDeque is as follows:
\index{iDeque}
\begin{verbatim}
typedef struct deque_t Deque;
typedef struct _DeQueueInterface {
    void (*Apply)(Deque *d,int (*fn)(void *e,void * arg),void *arg);
    int (*Back)(Deque *d,void *outbuf);
    int (*Clear)(Deque *Q);
    size_t (*Contains)(Deque * d, void* item);
    Deque *(*Copy)(Deque *d);
    Deque *(*Create)(size_t elementSize);
    int (*deleteIterator)(Iterator *);
    int (*Equal)(Deque *d1,Deque *d2);
    int (*Erase)(Deque * d, void* item);
    int (*Finalize)(Deque *Q);
    unsigned (*GetFlags)(Deque *Q);
    Deque *(*Load)(FILE *stream, ReadFunction readFn,void *arg);
    Iterator *(*newIterator)(Deque *Deq);
    int (*Save)(Deque *d,FILE *stream, SaveFunction saveFn,void *arg);
    unsigned (*SetFlags)(Deque *Q,unsigned newFlags);
    size_t (*Size)(Deque *Q);
    ErrorFunction (*SetErrorFunction)(Deque *d,ErrorFunction); 
    size_t (*Sizeof)(Deque *d);
    int (*PushBack)(Deque *Q, void *Element);
    int (*PushFront)(Deque *Q, void *Element);
    int (*PopBack)(Deque *d,void *outbuf);
    int (*Front)(Deque *d,void *outbuf);
    int (*PopFront)(Deque *d,void *outbuf);
    } DequeInterface;

extern DequeInterface iDeque;
\end{verbatim}

The deque container can be implemented as an adaptor container, for instance based on a double linked list or in an vector. In any case the underlying container interface is not visible.
\api{Apply}
    void (*Apply)(Deque *d,int (Applyfn)(void *,void *),void *arg);
\end{verbatim} 
\apidescription
Will call the given function for each element. The first argument of the callback function receives an element of the array. The second argument of the callback is the arg argument that the Apply function receives and passes to  the callback. This way some context can be passed to the callback, and from one element to the next.
Note that the result of the callback is not used. This allows all kinds of result types to be accepted after a suitable cast.
If the array is read-only, a copy of the element will be passed to the callback function.
\apierrors
\doerror{BADARG} Either the deque or Applyfn are\Null.
\doerror{NOMEMORY} The list is read-only and there is no more memory to allocate the buffer to copy each element.
\api{Back}
    int (*Back)(Deque *d,void *outbuf);
\end{verbatim}
\apidescription
Copies into the given buffer the last element stored in the Deque d.
\apierrors
\doerror{BADARG} Either d or outbuf are\Null.
\returns
A positive value of the operation completed, zero if the container is empty, or a negative error code otherwise.

\api{Clear}
    int     (*Clear)(Deque *Q);
\end{verbatim}
\apidescription
Erases all elements stored in the queue and reclaims the memory used. The Deque object itself is not destroyed.
Errors
\doerror{BADARG} The deque pointer is\Null.
\doerror{READONLY} The deque is read-only. No modifications allowed.

\api{Contains}
    size_t  (*Contains)(Deque * d, void* item);
\end{verbatim}
\apidescription
Searches the deque for the given data, returning its (index one based) position or zero if not found. 
Errors
\doerror{BADARG} The deque pointer is\Null.
\returns
The index of element or zero if not found.


\api{Copy}
    Deque  *(*Copy)(Deque *d);
\end{verbatim}
\apidescription 
Makes a copy of the given deque. 
\apierrors
\doerror{BADARG} The deque pointer is\Null.
\doerror{NOMEMORY} Not enough memory to complete the operation.
\returns 
A pointer to the new container or\Null if the operation did not complete.

\api{Create}
    Deque  *(*Create)(size_t elementSize);
\end{verbatim}
\apidescription
Creates a new Deque container using “elementSize” as the size that each element will have.
\apierrors
\doerror{BADARG} The elementSize parameter is zero or bigger than what the implementation supports.
\doerror{NOMEMORY} Not enough memory to complete the operation.
\returns 
A pointer to the new container or\Null if the operation did not complete.
\example
    Deque *d = iDeque.Create(sizeof(myType));
    if (d == NULL) { /* Error handling */ }
\end{verbatim}

\api{Equal}
    int (*Equal)(Deque *d1,Deque *d2);
\end{verbatim}
\apidescription
Compares the given deques using their comparison function. If they differ in their size, flags, or compare functions they compare unequal. If any of their elements differ, they compare unequal.
If both d1 and d2 are\Null they compare equal. If both are empty, they compare equal.
\apierrors
None
\returns
The result is one if the deques are equal, zero otherwise.

\api{Front}
    int (*PeekFront)(Deque *d,void *outbuf);
\end{verbatim}
\apidescription
Copies into the given buffer the first element stored in the Deque d.
\apierrors
\doerror{BADARG} Either d or outbuf are\Null.
\returns
A positive value of the operation completed, zero if the container is empty, or a negative error code otherwise.


\api{Erase}
    int (*Erase)(Deque * d, void* item);
\end{verbatim}
\apidescription
Erases the first occurrence of the given element from the container if found, starting from the front.
\apierrors
\doerror{BADARG} The deque pointer or the item pointer are\Null.
\doerror{READONLY} The deque is read-only. No modifications allowed.
\returns
A positive number if the item was found and erased, zero if the item wasn't found, or a negative error code if the operation did not complete.

\api{Finalize}
    int (*Finalize)(Deque *d);
\end{verbatim}
\apidescription
Reclaims all memory used by the container erasing all elements, if any. Then it destroys the container object itself.
\apierrors
\doerror{BADARG} The deque or the element pointers are\Null.
\doerror{READONLY} The deque is read-only. No modifications allowed.
\returns
A positive number if the operation completed, a negative error code otherwise.

\api{GetFlags}
    unsigned (*GetFlags)(Deque *d);
\end{verbatim}
\apidescription
Retrieves the state of the flags. If the implementation doesn't support this field this function always returns zero.
\apierrors
\doerror{BADARG} The deque pointer is\Null.
\returns
The state of the flags field. 

\api{Load}
 Deque *(*Load)(FILE *stream,ReadFunction readFn,void *arg);
\end{verbatim}
\apidescription
Reads a deque previously saved with the Save function from the stream pointed to by stream. If readFn is not\Null, it will be used to read each element. The “arg” argument will be passed to the read function. If the read function is\Null, this argument is ignored and a default read function is used.
\apierrors
\doerror{BADARG} The given stream pointer is\Null.
\doerror{NOMEMORY} There is not enough memory to complete the operation.
\returns
A new deque or\Null if the operation could not be completed. Note that the function pointers in the deque are NOT saved in most implementations, nor any special allocator that was in the original table. In most implementations those values will be the values by default. To rebuild the original state the user should replace the pointers again in the new table.

\api{PopBack}
    int (*PopBack)(Deque *d,void *outbuf);
\end{verbatim}
\apidescription
Copies into the given buffer the last element stored in the Deque d, then erases the element from the deque.
\apierrors
\doerror{BADARG} Either d or outbuf are\Null.
\returns
A positive value of the operation completed, zero if the container is empty, or a negative error code otherwise.

\api{PopFront}
    int (*PopFront)(Deque *d,void *outbuf);
\end{verbatim}
\apidescription
Copies into the given buffer the first element stored in the Deque d, thnen erases the element from the deque.
\apierrors
\doerror{BADARG} Either d or outbuf are\Null.
\returns
A positive value of the operation completed, zero if the container is empty, or a negative error code otherwise.

\api{PushBack}
    int (*PushBack)(Deque *d,void *element);
\end{verbatim}
\apidescription
Adds the given element to the end of the deque. It is assumed that “element” points to a contiguous memory area of at least ElementSize bytes.  
\apierrors
\doerror{BADARG} The deque or the element pointers are\Null.
\doerror{READONLY} The deque is read-only. No modifications allowed.
\doerror{NOMEMORY} Not enough memory to complete the operation.
\returns
A positive number if the operation added a new element, or a negative error code if an error occurred.
\example
    Deque *d;
    double data = 4.5;
    int result = iDeque.PushBack(d,&data);
    if (result < 0) { /* Error handling */ }
\end{verbatim}

\api{PushFront}
    int (*PushFront)(Deque *d,void *element);
\end{verbatim}
\apidescription
Adds the given element to the start of the deque. It is assumed that “element” points to a contiguous memory area of at least ElementSize bytes.  
\apierrors
\doerror{BADARG} The deque or the element pointers are\Null.
\doerror{READONLY} The deque is read-only. No modifications allowed.
\doerror{NOMEMORY} Not enough memory to complete the operation.
\returns
A positive number if the operation added a new element, or a negative error code if an error occurred.
\example
    Deque *d;
    double data = 4.5;
    int result = iDeque.PushFront(d,&data);
    if (result < 0) { /* Error handling */ }
\end{verbatim}


\api{Save}
int (*Save)(Deque *d, FILE *out, SaveFunction Fn, void *arg);
\end{verbatim}
\apidescription
The contents of the given deque are saved into the given stream. If the save function pointer is not\Null, it will be used to save the contents of each element and will receive the arg argument passed to Save, together with the output stream. Otherwise a default save function will be used and arg will be ignored.
The output stream must be opened for writing and must be in binary mode.
\apierrors
\doerror{BADARG} The deque pointer or the stream pointer are\Null.
EOF A disk input/output error occurred.
\returns
A positive value if the operation completed, a negative value or EOF otherwise.
\example
    Deque *d;
    FILE *outFile;
    if (iDeque.Save(d,outFile,NULL,NULL) < 0) { 
        /* Handle error here */
    }
\end{verbatim}
%---------------------------------------------------------------------------------------------------------------------------------------
%                                             Generic
%---------------------------------------------------------------------------------------------------------------------------------------
\newpage
\section{The generic interfaces}
This interface allows the user to use containers in a generic way, ignoring its specific type.
Note that there is no "GenericContainer" object; you can't create any generic container. Once a specific container is created, it can be used as a generic container at any time since all containers comply with the generic interface. This interface just dispatches internally to the actual container and therefore incurs in a slight performance cost.
\footnote{
The Objective-C language has a similar constructs with its "Protocols". Several classes can share a common interface without any inheritance between them. Obviously in C there is no compiler support for this kind of programming, what forces your implementation to be careful about the order of the function pointers within all objects. A change in the order of those function pointers makes the object incompatible with the protocol specifications, and this can't be checked by the compiler.
All of this can be avoided, of course, if you just use the protocols designed and implemented by someone else.
}

Conceptually, the generic interfaces represent a base class (GenericContainer) and two derived classes: Sequential and Associative containers.
It would be possible to derive more classes, for instance a numeric container class that could be implemented in the future, This is left open for future releases of this specification.
\footnote{Two special cases of specialized arrays have been presented: an array of strings and an array of bits. Many other arrays are possible and surely necessary for numeric work, and they could be used as basis for vector extensions with hardware support. Another subject not mentioned in this specification  is multi-dimensional arrays.}
\subsection{Generic containers}
The general generic interface that encloses associative and sequential containers is as follows:
\index{iGenericContainer}
\begin{verbatim}
typedef struct GenericContainer GenericContainer;
typedef struct tagGenericContainerInterface {
    size_t (*Size)(GenericContainer *Gen);
    unsigned (*GetFlags)(GenericContainer *Gen);
    unsigned (*SetFlags)(GenericContainer *Gen,unsigned flags);
    int (*Clear)(GenericContainer *Gen);
    int (*Contains)(GenericContainer *Gen,void *Value);
    int (*Erase)(GenericContainer *Gen,void *objectToDelete);
    int (*Finalize)(GenericContainer *Gen);
    void (*Apply)(GenericContainer *Gen,
                  int (*Applyfn)(void *,void * arg),
                  void *arg);
    int (*Equal)(GenericContainer *Gen1,GenericContainer *Gen2);
    GenericContainer *(*Copy)(GenericContainer *Gen);
    ErrorFunction (*SetErrorFunction)(GenericContainer *Gen,
                                      ErrorFunction fn);
    size_t (*Sizeof)(GenericContainer *Gen);
    Iterator *(*newIterator)(GenericContainer *Gen);
    int (*deleteIterator)(Iterator *);
    int (*Save)(GenericContainer *Gen,FILE *stream, 
                SaveFunction saveFn,void *arg);
    GenericContainer *(*Load)(FILE *stream, 
                              ReadFunction readFn,void *arg);
    size_t GetElementSize(GenericContainer *Gen);
} GenericContainerInterface;
extern GenericContainerInterface iGenericContainer;
\end{verbatim}
This functions return the obvious results already described in the documentation of their container-specific counterparts and not repeated here. We only note the absence of a creation function, or any means to add an object.
\footnote{The "Erase" function  has been added to the generic interface because it has the same interface both in associative and sequential containers.The "Add" function was left out because in associative containers you need a key argument to add data. This could have been fixed by defining a structure with two fields that would be passed as a single argument, but that would make things more complex than they need to be}

Based on the generic interface, we have generic sequential and associative interfaces. They contain generic functions for adding and removing objects.
\subsection{Sequential containers}
These containers include all the functions of the GenericContainer interface, adding functions to use any sequential container as a stack, and functions for managing object replacement or addition.
\index{iSequentiaContainer}
\begin{verbatim}
typedef struct SequentialContainer SequentialContainer;
typedef struct tagSequentialContainerInterface {
    GenericContainerInterface Generic;
    int (*Add)(SequentialContainer *SC,void *Element);
    void *(*GetElement)(SequentialContainer *SC,size_t idx);
    int (*Push)(SequentialContainer *Gen,void *Element);
    int (*Pop)(SequentialContainer *Gen,void *result);
    int (*InsertAt)(SequentialContainer *SC,size_t idx, void *newval);
    int (*EraseAt)(SequentialContainer *SC,size_t idx);
    int (*ReplaceAt)(SequentialContainer *SC, 
                     size_t idx, void *element);
    int (*IndexOf)(SequentialContainer *SC,
                   void *ElementToFind,size_t *result);
    int (*Append)(SequentialContainer *SC1,SequentialContainer *SC2);
} SequentialContainerInterface;
extern SequentialContainerInterface iSequentialContainer;
\end{verbatim}
\subsection{Associative containers}
These containers include all the functions of the GenericContainer interfaces and add functions for inserting and removing objects.
\index{iAssociativeContainer}
\begin{verbatim}
typedef struct AssociativeContainer AssociativeContainer;
typedef struct tagAssociativeContainerInterface {
    GenericContainerInterface Generic;
    int (*Add)(SequentialContainer *SC,void *key,void *Element);
    void *(*GetElement)(AssociativeContainer *SC,void *Key);
    int (*Replace)(AssociativeContainer *SC, void *Key, void *element);
} AssociativeContainerInterface;
extern AssociativeContainerInterface iAssociativeContainer;
\end{verbatim} 
\chapter{Enhancing the library}
No design can ever cover all special cases that can arise during development. The advantage of the interface design is that you can enhance the library by subclassing functions that add functionality you need when absent.
Subclassing means in this context that you replace a function of the library with a new function written by you that either replaces completely the functionality of the library or that either before or after the library function adds some code that implements an enhancement.

There are several ways to enhance the library in this way:
\begin{enumerate}
\item Replace the function in the container interface object. This affects all containers of this type, including those that are already created. This involves simply assigning to the function you want to replace a new function pointer that points to a compatible function. You can save the old value and add some functionality, call the old function pointer to do what the library does, then you can add code that runs after the old library function has finished.
\item Replace the function in a copy of the functions table of a single object. This way is less intrusive than the former, since only one container is affected: the one where you modify the function table. The downside is that instead of using the simple syntax:\par\noindent \texttt{iList.Add} \par you have to use the container's table:\par \texttt{Container->VTable->Add(...)} \par This represents quite a different syntax, but this can be less of a problem if you hide it under some convenient macros \footnote{For instance you can use \texttt{iList\_Add} for \texttt{iList.Add}, or similar conventions. The specifications of the library do not define those macros to avoid invasion of the user's name space}.

On the up side, another advantage of this syntax is that you do not need to change your source code if you change the type of the container. If you write: \par \noindent \texttt{myContainer->Vtable->Add(myContainer,object);}\par \noindent this will stay the same for lists, arrays, string collections or whatever sequential container you are using. You can then change completely the type of the container just by changing the declaration.
\end{enumerate}

\chapter{Applications}
\section{Mapcar}
\index{mapcar}
The lisp function "mapcar" produces a map by applying a given function to each element of a list.
\begin{verbatim}
(mapcar #'abs '(3 -4 2 -5 -6)) => (3 4 2 5 6) 
\end{verbatim}
We can reproduce this function by using "Apply". In the extra argument we pass a structure of two members: 
\begin{itemize}
\item A function to call (in the above example it would be a function to calculate the absolute value)
\item A list container where the result would be stored
\end{itemize}
Our function receives then (as all functions called by Apply) two arguments, the element and a pointer to our structure. Here is a sketch of how could it be done:
\begin{verbatim}
#include <containers.h>
struct MapcarArgs {
    void  *(*fn)(void *);
     List *Result;
};
\end{verbatim}
We keep some generality by using a general prototype and definition for the function we are using. We could have defined the callback as:
\begin{verbatim}
    int (*fn)(int *);
\end{verbatim}
That prototype would have been unusable for lists that use doubles, for instance. With the current definition we can use this "MapcarArgs" structure with any other list.

The actual function we are calling encapsulates all knowledge about the data stored in the list and the operation we perform with that data. The other parts of the software do not need to know anything about it.  It returns a static pointer to the result of the operation it performs using the given element as data that will be overwritten at each call. The intended usage is to save that result before making the next call.
It can be defined as follows:
\begin{verbatim}
void *DoAbsValue(void *element)
{
    static int result = *(int *)element;
    if (result < 0)
        result = -result;
    return &result;
}
/* This function will be directly called by "Apply". */
static int Applyfn(void *element, struct MapcarArgs *args)
{
    void *result = args->fn(element);
    int r = iList.Add(args->Result,result);
    return r;
}
List *mapcar(List *li,void *(*fn)(void *))
{
        struct MapcarArgs args;

        args.fn = fn;
        args.Result = iList.Create(iList.GetElementSize(li));
        if (args.Result == NULL)
                return NULL;
        iList.Apply(li,Applyfn,(void *)&args);
        return args.Result;
}

int main(void)
{
    List *li = iList.Create(sizeof(int));
    List *newList;
    int i;
    int tab[] = {3,-4,2,-5,6};
    for (i=0; i<5;i++) {
        iList.Add(li,&tab[i]);
    }
    newList = mapcar(li,DoAbsValue);
}
\end{verbatim}
Still, our version of mapcar is still specific to lists. A more general version would use a sequential container to make a mapcar function that would be able to work with any type of sequential container. 

The basic idea is to provide an empty container of the desired result type as an extra argument to mapcar. We use an iterator instead of "Apply", obtaining a single compact function that will take any sequential container as input an add the result of the function to any type of sequential container.
\begin{verbatim}
int mapcar(SequentialContainer *src,         /* The source container */
           void *(*fn)(void *),/* Function to call with each element */
           SequentialContainer *result)   /* The resulting container */
{
        Iterator *it = iSequentialContainer.newIterator(src);
        int r=1;
        void *obj;
        if (it == NULL)
               return CONTAINER_ERROR_NOMEMORY;
        for (obj = it->GetFirst(it);
              obj != NULL;
              obj = it->GetNext(it)) {
              void *tmp = fn(obj);
              int r = iSequentialContainer.Add(result,tmp);
              if (r < 0) {
                    /* In case of any error return a partial result 
                    and the error code */
                    break;
               }
        }
        deleteIterator(it);
        return r;
}
\end{verbatim}
Other similar functions can be built from this model. For instance "mapcon", a function that needs two containers to build a resulting container. The result is  made out of the results of a binary function that will receive one element from each container. 

Its implementation is trivially deduced from the above function:
\index{mapcon}
\begin{verbatim}
int mapcon(SequentialContainer *src1,*src2,  /* The input containers */
           void *(*fn)(void *,void *),  /* Function with 2 arguments */
           SequentialContainer *result)   /* The resulting container */
{
        Iterator *it1 = iSequentialContainer.newIterator(src1);
        Iterator *it2 = iSequentialContainer.newIterator(src2);
        int r=1;
        void *obj1,*obj2;
        if (it == NULL)
               return CONTAINER_ERROR_NOMEMORY;
        if (iSequentialContainer.GetElementSize(src1) != 
            iSequentialContainer.GetElementSize(src2)) {
            return CONTAINER_ERROR_INCOMPATIBLE;
        }
        for (obj1 = it1->GetFirst(it1),obj2 = it2->GetFirst(it2);
              obj1 != NULL && obj2 != NULL;
              obj2 = it2->GetNext(it2),
              obj1 = it1->GetNext(it1)) {
              void *tmp = fn(obj1,obj2);
              int r = iSequentialContainer.Add(result,tmp);
              if (r < 0) {
                    /* In case of any error return a partial result 
                    and the error code */
                    break;
               }
        }
        deleteIterator(it1);
        deleteIterator(it2);
        return r;
}
\end{verbatim}
We can use it with a function  that adds its two arguments to add two containers:
\begin{verbatim}
void *DoAdd(void *element1,void *element2)
{
    static int result = *(int *)element1 + *(int *)element2;
    return &result;
}
\end{verbatim}
Note that not all errors are detected, and we stop at the smallest container, producing a result compatible with the smallest of both arguments.
Note too that we make a very superficial compatibility test to see if the arguments contain the same type of object, using their size as an indication. This test would ignore elements of the same size but incompatible, for instance floats and 32 bit integers, or 64 bit integers and double precision elements, etc.

The standard answer to the above problems is to point out that C has a tradition of keeping things simple and expecting programmers that take care of low level details. If you want more error support, you will find out with minimal research a lot of languages ready to make all kinds of hand holding for you.
\section{Portability}
The main objective of this work is to allow portable data structures and portable containers in C. This structures allow to increase the portability of programs across OS differences if the underlying OS functionality is encapsulated in a portable data structure. For instance, a function that returns a string collection with all the file names in a directory would allow the software that uses it to be implemented differently in each OS, yielding always the same result: a string collection.

\chapter{The sample implementation}
The objective of the sample implementation is to serve as a guide for the implementers of this proposal. It is not the fastest implementation and it is not the most efficient or compact one. As any other software, it contains bugs, that I hope to iron out with time.

\section{Data structures}
All container data structures are composed of two parts:
\begin{enumerate}
\item A header part, containing a pointer to the functions table and some other fields. This 'generic' part is at the start of all container header structures.
\item A container specific part, containing auxiliary structures and data needed for the specific container at hand.
\end{enumerate}
\subsection{The generic part}
The first part of all container data structures is the same for each container. This allows to implement conceptually an abstract class of objects: the 'generic' container.
\index{Generic Container!structure}
\begin{verbatim}
struct GenericContainer {
    GenericContainerInterface *vTable;
    size_t Size;
    unsigned Flags;
    size_t ElementSize;
};
\end{verbatim}
\begin{enumerate}
\item \texttt{Vtable}. All containers in the sample implementation contain a pointer to the table of functions of their interface.
\item \texttt{Size}. The number of elements this container stores.
\item \texttt{Flags}. Stores the state of the container. The only flag the sample implementation uses is the \texttt{READ\_ONLY\_FLAG} but many others are possible, for instance a 'locked' flag for multi-threading access, or a 'copy on write' flag for lazy copy, etc.
\item \texttt{ElementSize}. All containers in the sample implementation can store objects of the same size. This is not really a limitation since you can store objects of ANY size by storing a pointer in the container.
An alternative design would store objects of any size but it would need to store the size of each object in addition to the data used by the object. The specialized containers like bitstrings, string collections or integer/double arrays do not need this field obviously, and its presence is optional.
\end{enumerate}
\subsection{Lists}
Single linked lists use a single pointer to the next element. The data for the element comes right behind that pointer to avoid the overhead that yet another pointer would represent.
\begin{verbatim}
typedef struct _list_element {
    struct _list_element *Next;
    char Data[MINIMUM_ARRAY_INDEX];\item{Compare}
} list_element;
\end{verbatim}
The list header uses this structure to store the elements.
\index{lists!structure}
\begin{verbatim}
struct _List {
    ListInterface *VTable;  
    size_t count;           
    unsigned Flags;	
    unsigned timestamp;   
    size_t ElementSize;   
    list_element *Last;   
    list_element *First;  
    CompareFunction Compare; 
    ErrorFunction RaiseError; 
    ContainerHeap *Heap;
    ContainerMemoryManager *Allocator;
};
\end{verbatim}
In the public \texttt{containers.h} header file we refer always to an abstract structure \texttt{\_List}. We define it here. This schema allows other implementation to use the same header with maybe radically different implementations of their data structure.
\begin{enumerate}
\item \texttt{Vtable}, \texttt{count}, \texttt{Flags}, \texttt{ElementSize}. This fields were described in the generic container section.
\item \texttt{timestamp}. This field is incremented at each modification of the list, and allows the iterators to detect if the container changes during an iteration: they store the value of this field at the start of the iteration, and before each iteration they compare it with its current value. If there are any changes, they return\Null.
\item \texttt{Last}. Stores a pointer to the last element of the list. This allows the addition of an element at the end of the list to be fast, avoiding a complete rescan of the list. This field is an optimization, all algorithms of a single linked list would work without this field.
\item \texttt{First}. The start of the linked list.
\item \texttt{Compare}. A comparison function for the type of elements stored in the list.
\item \texttt{RaiseError}. A function that will be called when an error occurs. This field is necessary only if you want to keep the flexibility of having a different error function for each list that the client software builds. An alternative implementation would store a pointer to an error function in the interface.
\item \texttt{Allocator}. A set of functions that allocates memory for this list. In an implementation that needs less flexibility and is more interested in saving space it could be replaced by the default allocator.
\end{enumerate}
The sample implementation has certainly a quite voluminous header because of a design decision to keep things very flexible. Other implementations could trim most of the fields, and an absolute minimal implementation would trim \texttt{Last}, \texttt{Compare}, \texttt{RaiseError}, \texttt{Heap}, and \texttt{Allocator}. If the implementation assumes that only one iterator per container is allowed, the \texttt{timestamp} field could be replace by a single bit ('changed') in the \texttt{Flags} field.\footnote{The function \texttt{newContainer} would clear the 'changed' bit, and the iterator functions would test if it is still clear. All modifications function would set it to one. This simple schema becomes problematic when you consider what happens when an invalid iterator is used again. In the simple one bit schema if the flag has been cleared, the iterator goes on, in the more expensive schema of the sample  implementation, the stalled iterators are never restartable until the counter wraps around to the same value.}
\subsection{Double linked lists}
This container has a very similar structure to the single linked ones
\begin{verbatim}
typedef struct _dlist_element {
    struct _dlist_element *Next;
	struct _dlist_element *Previous;
    char Data[MINIMUM_ARRAY_INDEX];
} dlist_element;
\end{verbatim}
We have now two pointers followed by the stored data. All other fields are exactly identical to the ones in the single linked list. The single difference is the existence of a free list. This could have been done in the single linked list implementation too.
\index{Dlist!structure}
\begin{verbatim}
struct Dlist {
    DlistInterface *VTable;
    size_t count;        
    unsigned Flags;
    unsigned timestamp;
    size_t ElementSize;
    dlist_element *Last; 
    dlist_element *First;
    dlist_element *FreeList;
    CompareFunction Compare;
    ErrorFunction RaiseError; 
	ContainerHeap *Heap;
	ContainerMemoryManager *Allocator;
};
\end{verbatim}

\subsection{Vector}
Arrays are the containers that use the smallest overhead per element: zero. The only overhead is the header structure, whose cost is amortized since it is fixed for all elements that the array can hold.

This is a 'flexible' array however, what means that there is some spare space allocated for allowing further growth, and that different allocation strategies can be followed when allocating a new chunk of array space when the existing array is full.
\index{Vector!structure}
\begin{verbatim}
struct _Vector {
    VectorInterface *VTable;
    size_t count;          
    unsigned int Flags;    
    size_t ElementSize;	
    void *contents;        
    size_t capacity;       
    unsigned timestamp;
    CompareFunction CompareFn;
    ErrorFunction RaiseError;
    ContainerMemoryManager *Allocator;
} ;
\end{verbatim}
\begin{enumerate}
\item \texttt{Vtable}, \texttt{count}, \texttt{Flags}, \texttt{ElementSize}. This fields were described in the generic container section.
\item \texttt{CompareFn, RaiseError, timestamp} and \texttt{Allocator} were described in the \texttt{List} container.
\item \texttt{capacity}. Stores the number of elements this container can hold without resizing.
\item \texttt{contents}. Points to an array of \texttt{capacity} elements, each of size \texttt{ElementSize}.
\end{enumerate}
\subsection{Dictionary}
This container consists of an array of single linked lists. It could have been done with an \texttt{Vector} of \texttt{List} containers but a dedicated implementation is justified because of a greater efficiency. The advantages of the \texttt{Vector} container (secured access, flexible expansion) are not needed since the array has a fixed length that never changes.
\index{Dictionary!structure}
\begin{verbatim}
struct _Dictionary {
    DictionaryInterface *VTable;
    size_t count;
    unsigned Flags;
    size_t size;
    ErrorFunction RaiseError;
    unsigned timestamp;
    size_t ElementSize;
    ContainerMemoryManager *Allocator;
    unsigned (*hash)(const unsigned char *Key);
    struct DataList {
        struct DataList *Next;
        unsigned char *Key;
        char *Value;
    } **buckets;
};
\end{verbatim}
\begin{enumerate}
\item \texttt{Vtable}, \texttt{count}, \texttt{Flags}, \texttt{ElementSize}. This fields were described in the generic container section.
\item \texttt{RaiseError, timestamp} and \texttt{Allocator} were described in the \texttt{List} container.
\item \texttt{capacity}. Stores the number of elements this container can hold without resizing.
\item \texttt{size}. The number of different lists that the hash table can contain. This is normally a prime number.
\item \texttt{hash}. A hash function for character strings.
\item \texttt{buckets}. A table of pointers to lists of \texttt{DataList} structures.
\end{enumerate}
\subsection{String collection}
String collections are just flexible arrays of pointers to C character strings. They share all the fields of the Vector container, the only specific field is a context that is passed to the string comparison function. This context can contain flags or other information to use with special text encodings (wide characters for instance) or other data like regular expressions, etc.
\index{StringCollection!structure}
\begin{verbatim}
struct StringCollection {
    StringCollectionInterface *VTable;
    size_t count; 
    unsigned int Flags;
    unsigned char **contents;
    size_t capacity;
    size_t timestamp;
    ErrorFunction RaiseError;
    StringCompareFn strcompare;
    CompareInfo *StringCompareContext;
    ContainerMemoryManager *Allocator;
};
\end{verbatim}
\subsection{The iterator data structure}
This data structure has two main parts:
\begin{itemize}
\item A public part declared in \texttt{containers.h}:
\index{Iterator!structure}
\begin{verbatim}
typedef struct _Iterator {
    void *(*GetNext)(struct _Iterator *);
    void *(*GetPrevious)(struct _Iterator *);
    void *(*GetFirst)(struct _Iterator *);
    void *(*GetCurrent)(struct _Iterator *);
    void *(*GetLast)(struct _Iterator *);
    void *(*CopyCurrent)(struct _Iterator *);
} Iterator;
\end{verbatim} 
This part contains only the functions that the interface offers.
\item A private, container specific part that comes right behind the public part and stores additional information that is needed for each container. For instance the list container will add following fields:
\index{ListIterator}
\begin{verbatim}
struct ListIterator {
    Iterator it;
    List *L;
    size_t index;
    list_element *Current;
    size_t timestamp;
    char ElementBuffer[1];
};
\end{verbatim}
User code should only see and use the public part, as if the iterator was only the public part. Internally all iterator functions are completely different functions, specific for the container they should iterate. It looks like from user code, as you were always calling the same function because the syntax and name is the same. This allows for a certain abstraction in the source code that uses this functions, allowing to express a whole range of algorithms in terms of general concepts.

Each of the functions that implement \texttt{GetNext} \texttt{GetFirst}, etc starts with a cast of the input argument that is declared as an \texttt{Iterator} structure to a concrete container iterator like our \texttt{ListIterator} above.

In all those structures there is a common ground. They have:
\begin{enumerate}
\item A pointer to the container the iterator is using.
\item Some fields for storing the current position within the container, i.e. a cursor.
\item A \texttt{timestamp} field to detect if the container has changed during the iteration.
\item A buffer that allows the iterator to store an element of the container fore returning a pointer to this area that contains a copy of the current element instead of a pointer directly to the element data. This allows to maintain the read only semantics.
\end{enumerate}
\end{itemize}
There is currently no way to know when you delete a container if there are iterators that are using it. This could be detected by simply having a counter of the number of iterators a container has, but that would mean more overhead for the already fat header objects...
\section{The code}
Only one container will be shown here in full: the List container. For the others, only some functions will be explained to save space. You are 
invited to read the distributed code of course that is part of this work.
\subsection{List}
\index{lists!code}
\newcommand{\container}{list}
\function{Add}
static int Add(List *l,void *elem)
{
    list_element *newl;

    /* Error checking ellided */
    newl = new_link(l,elem,"iList.Add");
    if (newl == NULL) return CONTAINER_ERROR_NOMEMORY;
    if (l->count ==  0) {                /* 1 */
        l->First = newl;
    }
    else {
        l->Last->Next = newl;
    }
    l->Last = newl;
    l->timestamp++;
    ++l->count;                         /* 2 */
    return 1;
}
\end{verbatim}
This function adds one element at the end. If the list is empty it just establishes the start of the list, if not, it adds it after the last element and makes the new list element the last. Errors leave the list unchanged. Exclusive access to the list is needed between the point marked (1) and the point marked (2) in the code.
\function{AddRange}
static int AddRange(List * AL,size_t n, void *data)
{
    unsigned char *p;

    /* Error checking snipped */
    p = data;
    while (n > 0) {
        int r = Add(AL,p);
        if (r < 0) {
            return r;
        }
        p += AL->ElementSize;
        n--;
    }
    return 1;
}
\end{verbatim}
This function calls repeatedly \texttt{Add} for each element of the given array. Note that at compile time we do not know the size of each element and we can't index into this array. We just setup a generic pointer to the start of the data area, and increment it by the size of each element at each iteration. 

If an error occurs when adding elements this function does not try to erase the newly added elements, returning an incoherent list. This is a bug
that should be corrected in future versions. 
\function{Append}
static int Append(List *l1,List *l2)
{

    /* Error checking  elided */
    if (l1->count == 0) {
        l1->First = l2->First;
        l1->Last = l2->Last;
    }
    else if (l2->count > 0) {
        if (l2->First)
            l1->Last->Next = l2->First;
        if (l2->Last)
            l1->Last = l2->Last;
    }
    l1->count += l2->count;
    l1->timestamp++;
    l2->Allocator->free(l2);
    return 1;
}
\end{verbatim}
This function  adds the second argument list to the first one. The second list is destroyed because all its elements are inserted into the first one. The result is obtained by pointer manipulation: no data is moved at all, and any pointers to the objects in the second list remain valid.

\function{Apply}
static int Apply(List *L,int (Applyfn)(void *,void *),void *arg)
{
    list_element *le;
    void *pElem=NULL;

    /* Null error checking ellided */
    le = L->First;
    if (L->Flags&CONTAINER_LIST_READONLY) {
        pElem = malloc(L->ElementSize);
        if (pElem == NULL) {
            L->RaiseError("iList.Apply",CONTAINER_ERROR_NOMEMORY);
            return CONTAINER_ERROR_NOMEMORY;
        }
    }
    while (le) {
        if (pElem) {
            memcpy(pElem,le->Data,L->ElementSize);
            Applyfn(pElem,arg);
        }
        else Applyfn(le->Data,arg);
        le = le->Next;
    }
    if (pElem)
        free(pElem);
    return 1;
}
\end{verbatim}
This function calls the given function for each element. If the container is read only, a copy of each element is passed to the called function. This 
copy is allocated with "malloc" because it is used for internal purposes, and the standard allocator for the list could be a heap based, i.e. one that 
doesn't really free any memory. That could be a problem if repeated calls to \texttt{Apply} are done.

This function does not pass any pointer to the called function to mark the list as changed if the data passed to it is rewritten. This means that 
there is no way to let the called function inform the rest of the software of any modifications. This can be justified by the fact that only the data, 
not the container itself can be modified, but this can be tricky in multi-threaded environments. Other implementations could pass some pointer or away 
to inform the rest of the software that a modification has been done.
\function{Clear}
static int Clear(List *l)
{
    if (l->Heap)
        iHeap.Destroy(l->Heap);
    else {
        list_element *rvp = l->First,*tmp;
        while (rvp) {
            tmp = rvp;
            rvp = rvp->Next;
            l->Allocator->free(tmp);
        }
    }
    l->count = 0;
    l->Heap = NULL;
    l->First = l->Last = NULL;
    l->Flags = 0;
    l->timestamp = 0;
    return 1;
}
\end{verbatim}
This function should clear all stored elements and reset some fields of the header structure so that the resulting list header is almost the same as when it was created. The only difference is that any functions like the comparison function or the error function are not cleared. If they were changed by the user they still remain changed.
\function{Copy}
static List *Copy(List *l)
{
    List *result;
    list_element *elem,*newElem;

     /* Null error checking ellided */
    result = iList.CreateWithAllocator(l->ElementSize,l->Allocator);
    if (result == NULL) {
        l->RaiseError("iList.Copy",CONTAINER_ERROR_NOMEMORY);
        return NULL;
    }
    result->Flags = l->Flags;   /* Same flags */
    result->VTable = l->VTable; /* Copy possibly subclassed methods */
    result->Compare = l->Compare; /* Copy compare function */
    result->RaiseError = l->RaiseError;
    elem = l->First;
    while (elem) {
        newElem = new_link(result,elem->Data,"iList.Copy");
        if (newElem == NULL) {
            l->RaiseError("iList.Copy",CONTAINER_ERROR_NOMEMORY);
            result->VTable->Finalize(result);
            return NULL;
        }
        if (elem == l->First) {
           result->First = newElem;
        }
        else {
           result->Last->Next = newElem;
        }
        result->Last = newElem;
        elem = elem->Next;
        result->count++;
    }
    return result;
}
\end{verbatim}
This function requires a non null list pointer. It creates a header structure, and fills some of it fields with the corresponding fields of the source list:
\begin{enumerate}
\item The allocator
\item The flags.
\item The table of functions. This is necessary in case some of those functions have been sub-classed.
\item The comparison function
\item The error function
\end{enumerate}
If an error occurs during the copy, probably because of lack of memory, the new list is destroyed and the result is\Null.
Otherwise elements are added at the growing end of the list.
\function{Contains}
static int Contains(List *l,void *data)
{
    size_t idx;
    return (IndexOf(l,data,NULL,&idx) < 0) ? 0 : 1;
}
\end{verbatim}
The \texttt{Contains} function is just a cover function for \texttt{IndexOf}.
\function{CopyElement}
static int CopyElement(List *l,size_t position,void *outBuffer)
{
    list_element *rvp;

    /* Error checking ellided */
    rvp = l->First;
    while (position) {
        rvp = rvp->Next;
        position--;
    }
    memcpy(outBuffer,rvp->Data,l->ElementSize);
    return 1;
}
\end{verbatim}
After the error checking, this function positions at the given element and copies its contents into the  given buffer.
Other designs are obviously possible. 
\begin{itemize}
\item This function could return a newly allocated buffer. This poses other problems like the type of allocator to use. If we use the list allocator we could run into problems if it is a specialized allocator that is designed for allocating list elements from a pool where no 'free' operation exists. Another, more important problem with that solution is that it forces an allocation when none is necessary if the buffer you use is stack based.
\item The function could require the buffer length to be sure there are no buffer overflows. This solution was discarded because it actually increases the chances of errors: you have to pass the size of the buffer, and if you pass the wrong one more problems arise. Is it an error if you pass more space than is actually needed? It could be an error if the passed size differs from the size of the elements stored or it could be just a consequence that you used the \texttt{sizeof(buffer)} expression with a bigger buffer than necessary.
\end{itemize}
\function{Create}
static List *Create(size_t elementsize)
{
    return CreateWithAllocator(elementsize,CurrentMemoryManager);
}
\end{verbatim}
This function just calls \texttt{CreateWithAllocator} using the current memory manager.
\function{CreateWithAllocator}
static List *CreateWithAllocator(size_t elementsize,
                       ContainerMemoryManager *allocator)
{
    List *result;

    if (elementsize == 0) {
        iError.RaiseError("iList.Create",CONTAINER_ERROR_BADARG);
        return NULL;
    }
    result = allocator->malloc(sizeof(List));
    if (result == NULL) {
        iError.RaiseError("iList.Create",CONTAINER_ERROR_NOMEMORY);
        return NULL;
    }
    memset(result,0,sizeof(List));
    result->ElementSize = elementsize;
    result->VTable = &iList;
    result->Compare = DefaultListCompareFunction;
    result->RaiseError = iError.RaiseError;
    result->Allocator = allocator;
    return result;
}
\end{verbatim}
After doing some error checking, the creation function allocates and initializes the new container with its default values.

A big question is the alignment problem for the given size. This can't be checked and could lead to problems if you pass to this function any argument that is not the product of a sizeof expression.
\function{DefaultListCompareFunction}
static int DefaultListCompareFunction(const void *left,
                                      const void *right,
                                      CompareInfo *ExtraArgs)
{
        size_t siz=((List *)ExtraArgs->Container)->ElementSize;
        return memcmp(left,right,siz);
}
\end{verbatim}
The default element compare function is just a cover for \texttt{memcmp}. It is assumed that the user will replace it with a comparison function of its own if necessary.
\function{DefaultListLoadFunction}
static size_t DefaultLoadFunction(void *element,void *arg, FILE *Infile)
{
    size_t len = *(size_t *)arg;

    return fread(element,1,len,Infile);
}
\end{verbatim}
This function just reads an element from the disk file. Returns the result value of \texttt{fread}, what is OK for our purposes.
\function{DefaultSaveFunction}
static size_t DefaultSaveFunction(const void *element,void *arg, 
                                  FILE *Outfile)
{
    const unsigned char *str = element;
    size_t len = *(size_t *)arg;

    return fwrite(str,1,len,Outfile);
}
\end{verbatim}
This function just writes the given element to the disk. Together with the default load function they allow for a very effective serialization package for containers. Obviously here we have a shallow copy, and all this will never work for recursive saves, i.e. for elements that contain pointers.
\function{deleteIterator}
static int deleteIterator(Iterator *it)
{
    struct ListIterator *li;
    List *L;

    if (it == NULL) {
        iError.RaiseError("deleteIterator",CONTAINER_ERROR_BADARG);
        return CONTAINER_ERROR_BADARG;
    }
    li = (struct ListIterator *)it;
    L = li->L;
    L->Allocator->free(it);
    return 1;
}
\end{verbatim}
This routine retrieves the list header object from the hidden part of the iterator and uses its allocator object to free the memory used by the iterator.

The functions \texttt{newIterator} and \texttt{deleteIterator} should occur in pairs like many others in C: malloc and free, fopen and fclose, etc. It would be very easy to have in the header object a counter of iterators that should be zero when the list is destroyed or cleared.
\function{Equal}
static int Equal(List *l1,List *l2)
{
    list_element *link1,*link2;
    CompareFunction fn;
    CompareInfo ci;

    if (l1 == l2)
        return 1;
    if (l1 == NULL || l2 == NULL)
        return 0;
    if (l1->count != l2->count)
        return 0;
    if (l1->ElementSize != l2->ElementSize)
        return 0;
    if (l1->Compare != l2->Compare)
        return 0;
    if (l1->count == 0)
        return 1;
    fn = l1->Compare;
    link1 = l1->First;
    link2 = l2->First;
    ci.Container = l1;
    ci.ExtraArgs = NULL;
    while (link1 && link2) {
        if (fn(link1->Data,link2->Data,&ci))
            return 0;
        link1 = link1->Next;
        link2 = link2->Next;
    }
    if (link1 || link2)
        return 0;
    return 1;
}
\end{verbatim}
If two null pointers are passed to the \texttt{Equal} function it returns true. This is a design decision: \texttt{Equal} doesn't have any error result. Either the two objects are equal or not.

A redundant test is done at the end of the function: if the lists have the same count and all elements are equal, link1 and link2 should be\Null. If they aren't that means there is a memory overwrite problem somewhere...
\function{Erase}
static int Erase(List *l,void *elem)
{
    size_t idx;
    int i;

    if (l == NULL) {
        iError.RaiseError("iList.Erase",CONTAINER_ERROR_BADARG);
        return CONTAINER_ERROR_BADARG;
    }
    if (elem == NULL) {
        l->RaiseError("iList.Erase",CONTAINER_ERROR_BADARG);
        return CONTAINER_ERROR_BADARG;
    }
    if (l->count == 0) {
        return CONTAINER_ERROR_NOTFOUND;
    }
    i = IndexOf(l,elem,NULL,&idx);
    if (i < 0)
        return i;
    return RemoveAt(l,idx);
}
\end{verbatim}
This is a very inefficient implementation. The list will be traversed twice, the first by \texttt{IndexOf}, and the second by \texttt{RemoveAt}. The obvious solution is to merge both into one function.
\function{EraseRange}
static int EraseRange(List *l,size_t start,size_t end)
{
    list_element *rvp,*start_pos,*tmp;
    size_t toremove;
    if (end > l->count)
        end = l->count;
    if (start >= l->count)
        return 0;
    if (start >= end)
        return 0;
    toremove = end - start+1;
    rvp = l->First;
    while (rvp && start > 1) {
        rvp = rvp->Next;
        start--;
    }
    start_pos = rvp;
    rvp = rvp->Next;
    while (toremove > 1) {
        tmp = rvp->Next;
        if (l->Heap)
            iHeap.AddToFreeList(l->Heap,rvp);
        else {
            l->Allocator->free(rvp);
        }
        rvp = tmp;
        toremove--;
        l->count--;
    }
    start_pos->Next = rvp;
    return 1;
}\end{verbatim}
This function positions the cursor \footnote{Very often I use the name "rvp" for \textbf{r}o\textbf{v}ing \textbf{p}ointer} at the element before
the one where the range starts, and then erases until it reaches the end of the range.
\function{Finalize}
static int Finalize(List *l)
{
    int t=0;

    t = Clear(l);
    if (t < 0)
        return t;
    l->Allocator->free(l);
    return 1;
}
\end{verbatim}
This function should free the memory used by the header object. It is fundamental that this will never be done with an object not allocated with that iterator in the first place, i.e. when the user has called \texttt{Init} instead of \texttt{Create}. This can't be tested in a portable manner since there is no function to verify that a given memory space belongs or not to a given allocator.\footnote{This has been
discussed several times in the comp.lang.c discussion group, but the committee never followed any of those proposals}
\function{GetCurrent}
static void *GetCurrent(Iterator *it)
{
    struct ListIterator *li = (struct ListIterator *)it;

    if (li->L->count == 0)
        return NULL;    
    if (li->index == (size_t)-1) {
        li->L->RaiseError("GetCurrent",CONTAINER_ERROR_BADARG);
        return NULL;
    }
    if (li->L->Flags & CONTAINER_LIST_READONLY) {
        return li->ElementBuffer;
    }
    return li->Current->Data;
}
\end{verbatim}
Returns the current object pointed by the given iterator. This function should be called only after \texttt{GetFirst} is called. It verifies this by testing if a correct value is stored in the \texttt{index} field. This value is stored by the \texttt{newIterator} function. This simple algorithm avoids the usage of an uninitialized iterator at the cost of one integer comparison per call.


\function{GetFirst}
static void *GetFirst(Iterator *it)
{
    struct ListIterator *li = (struct ListIterator *)it;
    List *L;


    L = li->L;
    if (L->count == 0)
        return NULL;
    if (li->timestamp != L->timestamp) {
        L->RaiseError("iList.GetFirst",CONTAINER_ERROR_OBJECT_CHANGED);
        return NULL;
    }
    li->index = 0;
    li->Current = L->First;
    if (L->Flags & CONTAINER_LIST_READONLY) {
        memcpy(li->ElementBuffer,L->First->Data,L->ElementSize);
        return li->ElementBuffer;
    }
    return L->First->Data;
}
\end{verbatim}
This function should set the iteration at the first element of the container, ready to get the iteration started. After the error checking phase it returns a pointer to the data in the first element, or a pointer to a copy of that data if the container is read only.
\function{GetFlags}
static unsigned GetFlags(List *l)
{
    if (l == NULL) {
            iError.RaiseError("iList.GetFlags",CONTAINER_ERROR_BADARG);
            return (unsigned)CONTAINER_ERROR_BADARG;
    }
    return l->Flags;
}
\end{verbatim}
Just returns the value of the flags.
\function{GetNext}
static void *GetNext(Iterator *it)
{
    struct ListIterator *li = (struct ListIterator *)it;
    List *L;
    void *result;


    if (li == NULL) {
        iError.RaiseError("iList.GetNext",CONTAINER_ERROR_BADARG);
        return NULL;
    }
    L = li->L;
    if (li->index >= (L->count-1) || li->Current == NULL)
        return NULL;
    if (li->L->count == 0)
        return NULL;
    if (li->timestamp != L->timestamp) {
        L->RaiseError("GetNext",CONTAINER_ERROR_OBJECT_CHANGED);
        return NULL;
    }
    li->Current = li->Current->Next;
    li->index++;
    if (L->Flags & CONTAINER_LIST_READONLY) {
        memcpy(li->ElementBuffer,li->Current->Data,L->ElementSize);
        return li->ElementBuffer;
    }
    result = li->Current->Data;
    return result;
}
\end{verbatim}
Advances the cursor to the next element and returns either a pointer to it or a pointer to a copy if the list is read only. The test for the cursor being\Null avoids using \texttt{GetNext} with an uninitialized iterator.
\function{GetPrevious}
static void *GetPrevious(Iterator *it)
{
    struct ListIterator *li = (struct ListIterator *)it;
    List *L;
    list_element *rvp;
    size_t i;

    L = li->L;
    if (li->index >= L->count || li->index == 0)
        return NULL;
    if (li->timestamp != L->timestamp) {
        L->RaiseError("GetPrevious",CONTAINER_ERROR_OBJECT_CHANGED);
        return NULL;
    }
    rvp = L->First;
    i=0;
    li->index--;
    if (li->index > 0) {
        while (rvp && i < li->index) {
            rvp = rvp->Next;
            i++;
        }
    }
    li->Current = rvp;
    return rvp->Data;
}
\end{verbatim}
There were heated discussions about this function. In single linked lists it is necessary to go through the whole list at each call to this function. This is extremely inefficient and its usage should be avoided, it is much better to use double linked lists if you are interested in bi-directional cursor positioning. In the other hand this should be a required iterator feature, and rather than filling this function pointer with a function that just returns an error, the user is better served with a function that actually returns the previous item. Besides for short lists the performance lost is quite small, and would justify using lists with smaller overhead per item.\footnote{But then, if the lists are small, the greater overhead of the double linked lists is small too. You see, there were a lot of good arguments from both sides}.
\function{GetRange}
static List *GetRange(List *l,size_t start,size_t end)
{
    size_t counter;
    List *result;
    list_element *rvp;;

    result = iList.Create(l->ElementSize);
    result->VTable = l->VTable;
    if (l->count == 0)
        return result;
    if (end >= l->count)
        end = l->count;
    if (start > end || start > l->count)
        return NULL;
    if (start == l->count-1)
        rvp = l->Last;
    else {
        rvp = l->First;
        counter = 0;
        while (counter < start) {
            rvp = rvp->Next;
            counter++;
        }
    }
    while (start < end && rvp != NULL) {
        int r = result->VTable->Add(result,&rvp->Data);
        if (r < 0) {
            Finalize(result);
            result = NULL;
            break;
        }
        rvp = rvp->Next;
        start++;
    }
    return result;
}
\end{verbatim}
A new list is constructed from the given range of elements. The elements are copied. Any error during the construction of the new list provokes a\Null result: the copied elements are destroyed. Only correctly constructed ranges are returned. A recurring problem arises because it is impossible to report any details about the error that stops the copy. The result is actually boolean, either everything worked and there is a non\Null result, or something didn't. 

An alternative design would have an integer return code, and a pointer to a result. This option was discarded because it is cumbersome and the most likely reason for \texttt{Add} to fail is lack of memory.
\function{IndexOf}
static int IndexOf(List *l,void *ElementToFind,
                   void *ExtraArgs,size_t *result)
{
    list_element *rvp;
    int r,i=0;
    CompareFunction fn;
    CompareInfo ci;

    if (l == NULL || ElementToFind == NULL) {
        if (l)
            l->RaiseError("iList.IndexOf",CONTAINER_ERROR_BADARG);
        else
            iError.RaiseError("iList.IndexOf",CONTAINER_ERROR_BADARG);
        return CONTAINER_ERROR_BADARG;
    }
    rvp = l->First;
    fn = l->Compare;
    ci.Container = l;
    ci.ExtraArgs = ExtraArgs;
    while (rvp) {
        r = fn(&rvp->Data,ElementToFind,&ci);
        if (r == 0) {
            *result = i;
            return 1;
        }
        rvp = rvp->Next;
        i++;
    }
    return CONTAINER_ERROR_NOTFOUND;
}
\end{verbatim}
The design of this function went through several iterations. The big problem was the result type: a \texttt{size\_t}, that in most cases is an unsigned quantity. A negative error result then was out of the question. But then, how would you indicate an error? \footnote{The function \texttt{Contains} started its life as a way of avoiding all this problems}

A first solution was to return a 1 based index and reserve zero for the 'not found' value. That could work, but was the source of many bugs in the rest of the software when the value was used without decrementing it first. 

A second solution was to reserve a value within the \texttt{size\_t} range to represent the 'not found' result. That works, and it is doable, but produced other, more subtle, problems in the rest of the sofwtare since in all checks of a size\_t, it could be that \textsl{this} size\_t has a value that is actually the sentinel value of \texttt{IndexOf}: the tests tended to multiply and the handling of those tests started to become a problem.

Here you see the third iteration: the function receives a pointer to a size\_t that will be set if the function returns with a result greater than zero.

Another, completely different issue is the fact that in lists, this function is inefficient since it forces the function that uses the result to restart a list traversal to access the nth element. Much more efficient would be to do something immediately with the result, or to return a list element that allows the calling software to use it without going again through the list. 

Problems with those solutions is that they are not portable, and that they would expose the inner workings of the list container to the users. The \texttt{list\_element} structure is not even mentioned in the public containers.h.

\function{InitWithAllocator}
static List *InitWithAllocator(List *result,size_t elementsize,
	                       ContainerMemoryManager *allocator)
{
    if (elementsize == 0) {
        iError.RaiseError("iList.Init",CONTAINER_ERROR_BADARG);
        return NULL;
    }
    memset(result,0,sizeof(List));
    result->ElementSize = elementsize;
    result->VTable = &iList;
    result->Compare = DefaultListCompareFunction;
    result->RaiseError = iError.RaiseError;
    result->Allocator = allocator;
    return result;
}
\end{verbatim}
This function initializes a piece of storage to a list container. This allows the user to use stack storage for the list container, saving an allocation from the heap, and the corresponding need to free that storage.
\function{Init}
static List *Init(List *result,size_t elementsize)
{
    return InitWithAllocator(result,elementsize,CurrentMemoryManager);
}
\end{verbatim}
Uses the current memory manager to call InitWithAllocator.
\function{InsertAt}
static int InsertAt(List *l,size_t pos,void *pdata)
{
    list_element *elem;
    if (l == NULL || pdata == NULL) {
        if (l)
            l->RaiseError("iList.InsertAt",CONTAINER_ERROR_BADARG);
        else
            iError.RaiseError("iList.InsertAt",CONTAINER_ERROR_BADARG);
        return CONTAINER_ERROR_BADARG;
    }
    if (pos > l->count) {
        l->RaiseError("iList.InsertAt",CONTAINER_ERROR_INDEX);
        return CONTAINER_ERROR_INDEX;
    }
    if (l->Flags & CONTAINER_LIST_READONLY) {
        l->RaiseError("iList.InsertAt",CONTAINER_ERROR_READONLY);
        return CONTAINER_ERROR_READONLY;
    }
    if (pos == l->count) {
        return l->VTable->Add(l,pdata);
    }

    elem = new_link(l,pdata,"iList. InsertAt");
    if (elem == NULL) {
        l->RaiseError("iList.InsertAt",CONTAINER_ERROR_NOMEMORY);
        return CONTAINER_ERROR_NOMEMORY;
    }
    if (pos == 0) {
        elem->Next = l->First;
        l->First = elem;
    }
    else {
        list_element *rvp = l->First;
        while (--pos > 0) {
            rvp = rvp->Next;
        }
        elem->Next = rvp->Next;
        rvp->Next = elem;
    }
    l->count++;
    l->timestamp++;
    return 1;
}
\end{verbatim}
This inserts before the given index. It would have been equally possible to insert after, that is a more or less random decision.
\function{InsertIn}
static int InsertIn(List *l, size_t idx,List *newData)
{
    size_t newCount;
    list_element *le,*nle;

    if (idx > l->count) {
        l->RaiseError("iList.InsertIn",CONTAINER_ERROR_INDEX);
        return CONTAINER_ERROR_INDEX;
    }
    if (l->ElementSize != newData->ElementSize) {
        l->RaiseError("iList.InsertIn",CONTAINER_ERROR_INCOMPATIBLE);
        return CONTAINER_ERROR_INCOMPATIBLE;
    }
    if (newData->count == 0)
        return 1;
    newData = Copy(newData);
    if (newData == NULL) {
        l->RaiseError("iList.InsertIn",CONTAINER_ERROR_NOMEMORY);
        return CONTAINER_ERROR_NOMEMORY;
    }
    newCount = l->count + newData->count;
    if (l->count == 0) {
        l->First = newData->First;
        l->Last = newData->Last;
    }
    else {
        le = l->First;
        while (le && idx > 1) {
            le = le->Next;
            idx--;
        }
        nle = le->Next;
        le->Next = newData->First;
        newData->Last->Next = nle;
    }
    newData->Allocator->free(newData);
    l->timestamp++;
    l->count = newCount;
    return 1;
}
\end{verbatim}
Inserts the given list at the specified position.
\begin{enumerate}
\item Error checking. First argument must be non\Null and read/write. Second must be non\Null.
\item If the position given is exactly the same as the length of the receiving list, the second list is just appended to the first one.
\item Otherwise search the position and insert a copy of the elements in the second list.
\end{enumerate}
\function{Load}
static List *Load(FILE *stream, ReadFunction loadFn,void *arg)
{
    size_t i,elemSize;
    List *result,L;
    char *buf;
    int r;
    guid Guid;

    if (loadFn == NULL) {
        loadFn = DefaultLoadFunction;
        arg = &elemSize;
    }
    if (fread(&Guid,sizeof(guid),1,stream) <= 0) {
        iError.RaiseError("iList.Load",CONTAINER_ERROR_FILE_READ);
        return NULL;
    }
    if (memcmp(&Guid,&ListGuid,sizeof(guid))) {
        iError.RaiseError("iList.Load",CONTAINER_ERROR_WRONGFILE);
        return NULL;
    }
    if (fread(&L,1,sizeof(List),stream) <= 0) {
        iError.RaiseError("iList.Load",CONTAINER_ERROR_FILE_READ);
        return NULL;
    }
    elemSize = L.ElementSize;
    buf = malloc(L.ElementSize);
    if (buf == NULL) {
        iError.RaiseError("iList.Load",CONTAINER_ERROR_NOMEMORY);
        return NULL;
    }
    result = iList.Create(L.ElementSize);
    if (result == NULL) {
        iError.RaiseError("iList.Load",CONTAINER_ERROR_NOMEMORY);
        return NULL;
    }
    result->Flags = L.Flags;
    r = 1;
    for (i=0; i < L.count; i++) {
        if (loadFn(buf,arg,stream) <= 0) {
            r = CONTAINER_ERROR_FILE_READ;
            break;
        }
        if ((r=Add(result,buf)) < 0) {
            break;
        }
    }
    free(buf);
    if (r < 0) {
        iError.RaiseError("iList.Load",r);
        iList.Finalize(result);
        result = NULL;
    }
    return result;
}
\end{verbatim}

The load function is long and complex. As always, the process starts with error checking. All streams written to by its counterpart \texttt{Save} are 
marked with a container specific globally unique identifier (GUID). This ensures that a load function from the list container will not crash if passed a file that belongs to an array or a dictionary.

Then, the header object is read, what gives the data to continue the process, since we now know the number of elements and the size of each element.

A new list is created with the given element size, and we start reading \textsl{count} elements from the stream. Any error provokes the destruction of the elements read so far and a result of NULL.
\function{newIterator}
static Iterator *newIterator(List *L)
{
    struct ListIterator *result;
    
    if (L == NULL) {
        iError.RaiseError("iList.newIterator",CONTAINER_ERROR_BADARG);
        return NULL;
    }
    result = L->Allocator->malloc(sizeof(struct ListIterator));
    if (result == NULL) {
        L->RaiseError("iList.newIterator",CONTAINER_ERROR_NOMEMORY);
        return NULL;
    }
    result->it.GetNext = GetNext;
    result->it.GetPrevious = GetPrevious;
    result->it.GetFirst = GetFirst;
    result->it.GetCurrent = GetCurrent;
    result->L = L;
    result->timestamp = L->timestamp;
    result->index = (size_t)-1;
    result->Current = NULL;
    return &result->it;
}
\end{verbatim}
The creation of a new iterator involves just allocating and initializing values to their defaults.
\function{PopFront}
static int PopFront(List *l,void *result)
{
    list_element *le;

    if (l->count == 0)
        return 0;
    le = l->First;
    if (l->count == 1) {
        l->First = l->Last = NULL;
    }
    else l->First = l->First->Next;
    l->count--;
    if (result)
        memcpy(result,&le->Data,l->ElementSize);
    if (l->Heap) {
        iHeap.AddToFreeList(l->Heap,le);
    }
    else l->Allocator->free(le);
    l->timestamp++;
    return 1;
}
\end{verbatim}
Contrary to most versions of this function, \texttt{PopFront} does not return the data of the element but stores it in a pointer that it receives. If the pointer is\Null, the data is just discarded.

The problem with returning a pointer to the first element, is that the user code should remember to discard it when no longer needed, and it should discard it using the same allocator that the list used to allocate it. That would be a very error prone interface.
\function{PushFront}
static int PushFront(List *l,void *pdata)
{
    list_element *rvp;

    rvp = new_link(l,pdata,"Insert");
    if (rvp == NULL)
        return CONTAINER_ERROR_NOMEMORY;
    rvp->Next = l->First;
    l->First = rvp;
    if (l->Last == NULL)
        l->Last = rvp;
    l->count++;
    l->timestamp++;
    return 1;
}
\end{verbatim}
Lists are a good base to implement a stack. PushFront and PopFront take a constant and small time to complete and they would be much smaller if we would eliminate the error checking.
\function{RemoveAt}
static int RemoveAt(List *l,size_t position)
{
    list_element *rvp,*last,*removed;


    rvp = l->First;
    if (position == 0) {
        removed = l->First;
        if (l->count == 1) {
            l->First = l->Last = NULL;
        }
        else {
            l->First = l->First->Next;
        }
    }
    else if (position == l->count - 1) {
        while (rvp->Next != l->Last)
            rvp = rvp->Next;
        removed = rvp->Next;
        rvp->Next = NULL;
        l->Last = rvp;
    }
    else {
        last = rvp;
        while (position > 0) {
            last = rvp;
            rvp = rvp->Next;
            position --;
        }
        removed = rvp;
        last->Next = rvp->Next;
    }
    if (l->Heap) {
        iHeap.AddToFreeList(l->Heap,removed);
    }
    else l->Allocator->free(removed);
    l->timestamp++;
    --l->count;
    return 1;
}
\end{verbatim}
The operation when \texttt{RemoveAt} is called with the index of the last element is equivalent to the \texttt{PopBack} function, that is absent in the single linked list interface. After much discussions, we decided that the generic interface would have only Push and Pop, and that each container would fill those functions with the most efficient implementation available for it. For lists, the most efficient implementation is PopFront and PushFront. For arrays, the most efficient is PushBack and PopBack. For double linked lists is either.
\function{ReplaceAt}
static int ReplaceAt(List *l,size_t position,void *data)
{
    list_element *rvp;

    if (position == l->count-1)
        rvp = l->Last;
    else  {
        rvp = l->First;
        while (position) {
            rvp = rvp->Next;
            position--;
        }
    }
    memcpy(&rvp->Data , data,l->ElementSize);
    l->timestamp++;
    return 1;
}
\end{verbatim}
After error checking (not shown), position the cursor at the right item, then copy from the given data pointer the element size bytes needed.

An open issue is whether the "timestamp" field should be changed. Nothing in the list structure has been changed, only the data stored in the container. Any iterators will go on working as advertised even if this function is called to replace many items in the list. In the other hand, if  user programs were making assumptions about the data (for instance a search function doesn't always look again at past items to see if they have been changed) this could bad consequences. As a rule, any change will provoke the incrementing of the "timestamp" counter.
\function{Reverse}
static int Reverse(List *l)
{
    list_element *New,*current,*old;

    if (l->count < 2)
        return 1;
    old = l->First;
    l->Last = l->First;
    New = NULL;
    while (old) {
        current = old;
        old = old->Next;
        current->Next = New;
        New = current;
    }
    l->First = New;
    l->Last->Next = NULL;
    l->timestamp++;
    return 1;
}
\end{verbatim}
After the error checking, the list is reversed in place if the count of its element is bigger than 1.\footnote{Looks easy isn't it? It isn't. It took me a while to arrive at the code above. Even worst is the reversing of a double linked list}
\function{Save}
static int Save(List *L,FILE *stream, SaveFunction saveFn,void *arg)
{
    size_t i;
    list_element *rvp;

    if (saveFn == NULL) {
        saveFn = DefaultSaveFunction;
        arg = &L->ElementSize;
    }

    if (fwrite(&ListGuid,sizeof(guid),1,stream) <= 0)
        return EOF;

    if (fwrite(L,1,sizeof(List),stream) <= 0)
        return EOF;
    rvp = L->First;
    for (i=0; i< L->count; i++) {
        char *p = rvp->Data;

        if (saveFn(p,arg,stream) <= 0)
            return EOF;
        rvp = rvp->Next;
    }
    return 1;
}
\end{verbatim}
The format of the saved list container is:
\begin{enumerate}
\item The GUID of the list container: 128 bytes
\item The Header object
\item The data for all the elements of the list
\end{enumerate}
\function{Seek}
static void *Seek(Iterator *it,size_t idx)
{
    struct ListIterator *li = (struct ListIterator *)it;
    list_element *rvp;


    if (li->L->count == 0)
        return NULL;

    rvp = li->L->First;
    if (idx >= li->L->count-1) {
        li->index = li->L->count-1;
        li->Current = li->L->Last;
    }
    else if (idx == 0) {
        li->index = 0;
        li->Current = li->L->First;
    }
    else {
        li->index = idx;
        while (idx > 0) {
            rvp = rvp->Next;
            idx--;
        }
        li->Current = rvp;
    }
    return li->Current;
}
\end{verbatim}
This function positions the given iterator at the desired position. Several alternatives are possible, for instance position the iterator at a
given item. This can be obtained now only by calling first \texttt{IndexOf}, then \texttt{Seek}, what forces to go through the list twice.
\function{SetCompareFunction}
static CompareFunction SetCompareFunction(List *l,CompareFunction fn)
{
   CompareFunction oldfn = l->Compare;

   if (l == NULL) {
      iError.RaiseError("iList.SetCompareFunction",
                        CONTAINER_ERROR_BADARG);
      return NULL;
   }
   if (fn != NULL) {
      if (l->Flags&CONTAINER_LIST_READONLY) {
          l->RaiseError("iList.SetCompareFunction",
                        CONTAINER_LIST_READONLY);
      }
      else l->Compare = fn;
   }
   return oldfn;
}
\end{verbatim}
This function returns the old value of the comparison function and sets it to the new one, if the new one is not\Null. This allows to query the comparison function without changing it, avoiding yet another trivial function like GetComparisonFunction. This is just what in other languages like Objective C or others is called a \textsl{property} of the iList object. Objective C makes all this automatic with its \texttt{synthetise} directive.

In C there isn't any such hand holding and you have to write that code yourself. There are several other functions in the same style like \texttt{SetErrorFunction}, \texttt{Size} (that returns the \texttt{count} field) and \texttt{SetFlags}. They aren't listed here but you can look at the code by browsing through the list.c file distributed
with this software.
\function{Sizeof}
static size_t Sizeof(List *l)
{
    if (l == NULL) {
        return sizeof(List);
    }

    return sizeof(List) + 
           l->ElementSize * l->count + 
           l->count *sizeof(list_element);
}
\end{verbatim}
Returns the number of bytes used by the given list, including the data, and all overhead. For lists, tghis is the size of the header object, and for 
each element the overhead of a pointer to the next element and the size of each stored object. With a\Null list pointer returns the size of the list 
header object, what allows you to allocate buffers containing a header object and use the \texttt{Init} function.
\function{Sort}
static int Sort(List *l)
{
    list_element **tab;
    size_t i;
    list_element *rvp;
    CompareInfo ci;

    if (l == NULL) {
        iError.RaiseError("iList.Sort",CONTAINER_ERROR_BADARG);
        return CONTAINER_ERROR_BADARG;
    }
    if (l->count < 2)
        return 1;
    if (l->Flags&CONTAINER_LIST_READONLY) {
        l->RaiseError("iList.Sort",CONTAINER_ERROR_READONLY);
        return CONTAINER_ERROR_READONLY;
    }
    tab = l->Allocator->malloc(l->count * sizeof(list_element *));
    if (tab == NULL) {
        l->RaiseError("iList.Sort",CONTAINER_ERROR_NOMEMORY);
        return CONTAINER_ERROR_NOMEMORY;
    }
    rvp = l->First;
    for (i=0; i<l->count;i++) {
        tab[i] = rvp;
        rvp = rvp->Next;
    }
    ci.Container = l;
    ci.ExtraArgs = NULL;
    qsortEx(tab,l->count,sizeof(list_element *),lcompar,&ci);
    for (i=0; i<l->count-1;i++) {
        tab[i]->Next = tab[i+1];
    }
    tab[l->count-1]->Next = NULL;
    l->Last = tab[l->count-1];
    l->First = tab[0];
    l->Allocator->free(tab);
    return 1;

}
\end{verbatim}
This function basically builds an array and calls quicksort, nothing really fancy. Note that it calls a modified version of the library
function quicksort, since it needs to pass a context to it for the comparison function.
The default comparison function is listed below:
\begin{verbatim}
static bool lcompar (const void *elem1, const void *elem2,
                                       CompareInfo *ExtraArgs)
{
    list_element *Elem1 = *(list_element **)elem1;
    list_element *Elem2 = *(list_element **)elem2;
    List *l = (List *)ExtraArgs->Container;
    CompareFunction fn = l->Compare;
    return fn(Elem1->Data,Elem2->Data,ExtraArgs);
}
\end{verbatim}
The default comparison function pulls the list compare function and calls it with the extra arguments needed to
pass a context to it.
\function{UseHeap}
static int UseHeap(List *L, ContainerMemoryManager *m)
{
    if (L == NULL) {
        iError.RaiseError("iList.UseHeap",CONTAINER_ERROR_BADARG);
        return CONTAINER_ERROR_BADARG;
    }
    if (L->Heap || L->count) {
        L->RaiseError("UseHeap",CONTAINER_ERROR_NOT_EMPTY);
        return CONTAINER_ERROR_NOT_EMPTY;
    }
    if (m == NULL)
        m = CurrentMemoryManager;
    L->Heap = iHeap.Create(L->ElementSize+sizeof(list_element), m);
    return 1;
}
\end{verbatim}
This function installs a heap to be used by the list. This is very important for huge lists, since performance goes quickly down if you call malloc 
for each element you add to the list. Basically, the heap is just a way to allocate memory in blocks so that malloc calls are reduced.
\subsection{Queues}
Queues are, to use the C++ terminology, \textsl{adaptor} containers, i.e. containers based on other containers, in this case a list. We describe here
an implementation with the objective to show how those adaptors can be implemented, and how you can restrain the interface of the underlying container
with a small cost.

The data structure used is very simple:
\begin{verbatim}
typedef struct _Queue {
    QueueInterface *VTable;
    List *Items;
} _Queue;
\end{verbatim}
Just two fields: the interface and the underlying list.
We do not document here some functions of the queue interface that trivially call the corresponding List functions.

\function{Back}
static int Back(Queue *Q,void *result)
{
    size_t idx;
    if (Q == NULL) {
        iError.RaiseError("iQueue.Front",CONTAINER_ERROR_BADARG);
        return CONTAINER_ERROR_BADARG;
    }
    idx = iList.Size(Q->Items);
    if (idx == 0)
        return 0;
    return iList.CopyElement(Q->Items,idx-1,result);
}
\end{verbatim}
Returns the last element of the queue. We do not want to have any errors issued by the underlying list, so we test for\Null. We use the size as an index, except of course when the queue is empty.
\function{CreateWithAllocator}
static Queue *CreateWithAllocator(size_t ElementSize,
                                  ContainerMemoryManager *allocator)
{
    Queue *result = allocator->malloc(sizeof(Queue));

    if (result == NULL)
        return NULL;
    result->Items = iList.CreateWithAllocator(ElementSize,allocator);
    if (result->Items == NULL) {
        allocator->free(result);
        return NULL;
    }
    result->VTable = &iQueue;
    return result;
}
\end{verbatim}
Using the given allocator, we get memory for the Queue object, then for the list using the given allocator.
\function{Finalize}
static int Finalize(Queue *Q)
{
    ContainerMemoryManager *allocator = iList.GetAllocator(Q->Items);
    iList.Finalize(Q->Items);
    allocator->free(Q);
    return 1;
}
\end{verbatim}
We should free the queue header object with the same allocator we used for the list. We obtain it first, before we free the list.
\function{Front}
static int Front(Queue *Q,void *result)
{
    size_t idx;
    if (Q == NULL) {
        iError.RaiseError("iQueue.Front",CONTAINER_ERROR_BADARG);
        return CONTAINER_ERROR_BADARG;
    }
    idx = iList.Size(Q->Items);
    if (idx == 0)
        return 0;
    return iList.CopyElement(Q->Items,0,result);
}
\end{verbatim}
Same as \texttt{Back}. We make the error checking to avoid errors when accessing the list.
\function{Sizeof}
static size_t Sizeof(Queue *q)
{
    if (q == NULL) return sizeof(Queue);
    return sizeof(*q) + iList.Sizeof(q->Items);
}
\end{verbatim}
If passed a\Null queue, we return the size of the Queue header object. Note that we do not return the size of the underlying list even if it has been allocated and uses up space. An alternative design would have required to take into account the list header as it would have been part of the overhead of the Queue object. But in that case we could never know the size of the Queue itself...
\subsection{The dictionary}
Dictionary is an instance of a hash table where the key is supposed to contain character strings (names) that are associated with some data. Hash 
tables are normal tables that are indexed by a hash function, i.e. a function that maps character strings into some integer that is used to index the 
table. At each slot of the table we find a linked list of elements that were classified by the hash function into the same slot. If we have a good hash function, i.e. one that spreads evenly the elements across the table, we can have a speed up for searching an element of the order of the table size, in the best case.

\subsubsection{Hashing}
\renewcommand{\container}{hash}
One of the important aspects of a dictionary implementation is to use a good hash function, i.e. one that distributes evenly the keys. I have picked
up for this work one of the most used functions of this type. Here is the documentation I found for this function in the Apache runtime:
\par\indent
\begin{quotation}{
This is the popular `times 33' hash algorithm which is used by perl and that also appears in Berkeley DB. This is one of the best
 known hash functions for strings because it is both computed very fast and distributes very well.
   
 The originator may be Dan Bernstein but the code in Berkeley DB cites Chris Torek as the source. The best citation I have found
 is "Chris Torek, Hash function for text in C, Usenet message  $<$27038@mimsy.umd.edu$>$ in comp.lang.c , October, 1990." in Rich
 Salz's USENIX 1992 paper about INN which can be found at  \underline{http://citeseer.nj.nec.com/salz92internetnews.html}.
\par

    The magic of number 33, i.e. why it works better than many other constants, prime or not, has never been adequately explained by
 anyone. So I try an explanation: if one experimentally tests all  multipliers between 1 and 256 (as I did while writing a low-level
 data structure library some time ago) one detects that even numbers are not useable at all. The remaining 128 odd numbers
 (except for the number 1) work more or less all equally well.  They all distribute in an acceptable way and this way fill a hash
 table with an average percent of approx. 86\%.
 
   If one compares the $chi^{2}$ 
 values of the variants (see Bob Jenkins ``Hashing FAQ'' at \underline{
 http://burtleburtle.net/bob/hash/hashfaq.html}  for a description  of $chi^{2})$, the number 33 not even has the best value. \par But the
 number 33 and a few other equally good numbers like 17, 31, 63, 127 and 129 have nevertheless a great advantage to the remaining
 numbers in the large set of possible multipliers: their multiply operation can be replaced by a faster operation based on just one
 shift plus either a single addition or subtraction operation. And  because a hash function has to both distribute good \textsl{and} has to
 be very fast to compute, those few numbers should be preferred.


                 -- Ralf S. Engelschall $<$rse@engelschall.com$>$
}                
\end{quotation}
Julienne Walker has another twist to this story. She says:\footnote{In the very interesting web page \par\noindent
http://eternallyconfuzzled.com/tuts/algorithms/jsw\_tut\_hashing.aspx\par\noindent In that page she also proposes to replace the addition operation with an XOR operations. She says that that improves the algorithm.}
\begin{quotation}
Bernstein hash

Dan Bernstein created this algorithm and posted it in a newsgroup. It is known by many as the Chris Torek hash because Chris went a long way toward popularizing it. Since then it has been used successfully by many, but despite that the algorithm itself is not very sound when it comes to avalanche and permutation of the internal state. It has proven very good for small character keys, where it can outperform algorithms that result in a more random distribution.

Bernstein's hash should be used with caution. It performs very well in practice, for no apparently known reasons (much like how the constant 33 does better than more logical constants for no apparent reason), but in theory it is not up to snuff. Always test this function with sample data for every application to ensure that it does not encounter a degenerate case and cause excessive collisions.
\end{quotation}
\function{hash}
static unsigned int hash(const unsigned char *key)
{
   unsigned int Hash = 0;
   const unsigned char *p;
		
    for (p = key; *p; p++) {
        Hash = Hash * 33 + scatter[*p];
    }
    return Hash;
}
\end{verbatim}
Note that I have slightly modified the algorithm by using a scatter table of 256 positions filled with random numbers. The objective is to avoid
that letters that appear frequently in the text would tend to cluster the keys in  the same position.

This default function may not be the best for the data in the user's application. The library has reserved a field in the dictionary header object for a pointer to a hash function that can be changed by the user.

\subsubsection{Creation}
Another important aspect of the dictionary implementation is the decision of how many slots the table should have. I have followed the recommendations of Dave Hanson in his Book "C interfaces and Implementations"\footnote{C Interfaces and Implementations, David R. Hanson, Addison Wesley. ISBN 0-201-49841-3 3rd printing June 2001 page 149}, and I use a small table of primes to decide what size the table should have:
\function{Init}
static Dictionary *Init(Dictionary *Dict,
                              size_t elementsize,size_t hint)
{
    size_t i,allocSiz;
    static unsigned primes[] = { 509, 509, 1021, 2053, 4093, 8191, 
                16381, 32771, 65521, 131071, 0 };
    for (i = 1; primes[i] < hint && primes[i] > 0; i++)
        ;
    allocSiz = sizeof (Dictionary);
    memset(Dict,0,allocSiz);
    allocSiz = primes[i-1]*sizeof (Dict->buckets[0]);
    Dict->buckets = CurrentMemoryManager->malloc(allocSiz);
    if (Dict->buckets == NULL) {
        return NULL;
    }
    memset(Dict->buckets,0,allocSiz);
    Dict->size = primes[i-1];
    Dict->hash = hash;
    Dict->VTable = &iDictionary;
    Dict->ElementSize = elementsize;
    Dict->Allocator = CurrentMemoryManager;
    Dict->RaiseError = iError.RaiseError;
    return Dict;
}
\end{verbatim}
The primes in the table are the nearest primes to the regular powers of two. Table sizes can range from 509 to more than 130000, what gives a really 
wide range of table sizes. Obviously, bigger tables could be necessary, and other specialized implementations could use the \textsl{hint} parameter
to extend this algorithm or to use a completely different algorithm altogether.

\subsubsection{Adding elements}
This operation consists of:
\begin{itemize}
\item hash the key to find a slot
\item go through the list at that slot to see if the key is already there
\item if key is already there replace
\item if key is absent add it in a new list item
\end{itemize}
\function{Add}
static int Add(Dictionary *Dict,const unsigned char *Key,void *Value)
{
    size_t i;
    struct DataList *p;
    unsigned char *tmp;

    if (Dict == NULL) 
        return NullPtrError("Add");
    if (Dict->Flags & CONTAINER_READONLY) 
        return ReadOnlyError(Dict,"Add");
    if (Key == NULL || Value == NULL) 
        return BadArgError(Dict,"Add");
    i = (*Dict->hash)(Key) % Dict->size;
    for (p = Dict->buckets[i]; p; p = p->Next) {
        if (strcmp(Key, p->Key) == 0)
            break;
    }
    Dict->timestamp++;
    if (p == NULL) {
        p = Dict->Allocator->malloc(sizeof(*p)+Dict->ElementSize);
        tmp = Dict->Allocator->malloc(1+strlen((char *)Key));
        if (p == NULL || tmp == NULL) {
            if (p) Dict->Allocator->free(p);
            if (tmp) Dict->Allocator->free(tmp);
            return NoMemoryError(Dict,"Add");
        }
        p->Value = (void *)(p+1);
        strcpy(tmp,Key);
        p->Key = tmp;
        p->Next = Dict->buckets[i];
        Dict->buckets[i] = p;
        Dict->count++;
    }
    memcpy((void *)p->Value,Value,Dict->ElementSize);
    return 0;
}
\end{verbatim}
Following the logical steps outlined above, we:
\begin{enumerate}
\item Call the hash function and use its result modulo the size of the slot table to fetch the list at the indicated slot.
\item See if the key was absent. If that is the case, we need to add a new key. We copy the key and allocate memory for a new list element 
that is initialized afterwards with the copied value of the key and inserted into the list.
\item Copy in the value. If it was a new key, its value is initialized, if the key was already present we overwrite the old contents.
\end{enumerate}
This function uses strcmp for comparing keys. This has the advantage of simplicity and speed, but in many other contexts a key comparison function 
would be necessary, to allow for keys in Unicode for instance, or for binary keys, for instance a GUID or similar binary data.

An important design decision was to replace the data associated with a key if the key is already there. This is a decision that has consequences for 
all associative containers, since it must be coherent in all of them. Since the "Insert" function allows for non-destructive insertions, Add was
allowed to replace contents since this is a very common operation for instance in some symbol tables, where "Insert if absent or replace if present"
is used to ensure that a symbol is associated with a certain value. \footnote{Note that the C++ \texttt{map::insert} does not replace an element}. At the same time we need a \texttt{Replace} function since we want to get an error if the element we want to replace was \textbf{not} found.
A small table makes this clearer
\par %\vspace{0.5cm}
\begin{center}
\begin{tabular}{|l | l|}
\hline 
Add & Insert or replace an item for a key \\
Insert & Insert, error if the key was present \\
Replace & Replace, error if key was absent \\
\hline
\end{tabular}
\end{center}

\subsubsection{Implementing iterators}
Iterators in sequential containers are conceptually easy: just start at the first and stop at the last. In associative containers however things are 
more complicated since there is no obvious way to order them. The solution retained in the sample implementation involves going through all elements
starting at the first element of the slots table, and for each slot go through the linked list of items if any. This guarantees to visit all elements 
in a fixed order. As an example of this here is the \texttt{Apply} function that should go through all elements calling the given function for each 
one of them.
\function{Apply}
static int Apply(Dictionary *Dict,
                 int (*apply)(const unsigned char *Key,
                             const void *Value, 
                             void *ExtraArgs),
                void *ExtraArgs)
{
    size_t i;
    unsigned stamp;
    struct DataList *p;

    if (Dict == NULL) {
        return NullPtrError("Apply");
    }
    if (apply == NULL)
        return BadArgError(Dict,"Apply");
    stamp = Dict->timestamp;
    for (i = 0; i < Dict->size; i++) {
        for (p = Dict->buckets[i]; p; p = p->Next) {
            apply(p->Key,p->Value, ExtraArgs);
            if (Dict->timestamp != stamp)
                return 0;
        }
    }
    return 1;
}
\end{verbatim}

As we outlined above, we start at slot zero, going upwards. If we find a non-empty slot, we go through the linked list of items.

Iterators are implemented using the same algorithm, and need conceptually two indexes to remember their position: a first index for the slots table, 
and another for the position in the list of items at that slot.

The implementation of the dictionary iterator is as follows:
\index{iterator!Dictionary}
\begin{verbatim}
struct DictionaryIterator {
   Iterator it;
   Dictionary *Dict;
   size_t index;
   struct DataList *dl;
   size_t timestamp;
   unsigned long Flags;
};
\end{verbatim}
The \texttt{index} field remembers the position in the slot table, and the \texttt{dl} field is just a small structure that contains a link to the 
next item in the linked list and a pointer to the key. Storing the list element itself spare us the work of going through all the list to position ourselves at each advance of the cursor in the list.
%---------------------------------------------------------------------------------------------------------------------------------------
%                                             debug malloc
%---------------------------------------------------------------------------------------------------------------------------------------
\subsubsection{Debugging malloc}
\label{Malloc}
\renewcommand{\container}{debugMalloc}
The library provides a sample of how a malloc used for debugging allocation problems could look like. It is designed to be enhanced and even if it
has several important features like detection of double free and buffer overflows, it is not a competitor for the professional versions you can find
in the market like valgrind or similar.
\function{Malloc}
static void *Malloc(size_t size)
{
    register char *r;
    register size_t *ip = NULL;

    size = ALIGN_DEFAULT(size);
    size += 3 * sizeof(size_t);
    r = malloc(size);
    if (r == NULL)
        return NULL;
    AllocatedMemory += size;
    ip = (size_t *) r;
    *ip++ = SIGNATURE;
    *ip++ = size;
    memset(ip, 0, size - 3*sizeof(size_t));
    ip = (size_t *) (&r[size - sizeof(size_t)]);
    *ip = MAGIC;
    return (r + 2 * sizeof(size_t));
}
\end{verbatim}
The algorithm is as follows:
\begin{itemize}
\item The given size will be aligned to a multiple of \texttt{size\_t}. It is assumed that this size is the size of a register, and will be 
good for any type of allocation. In some machines this may be completely wrong, for instance for some quantities the Intel processors need an
alignment of 16 bytes, and there is no implementation of \texttt{size\_t} with that size.
\item We reserve three words more than the requested size to store:
\begin{enumerate}
\item The "magic number". This is just an integer that will enable us to ensure that we are dealing with a valid block. Blocks that have this number two 
words below the address passed to our \texttt{Free} function will be assumed to be real blocks. There 
is of course a chance that the memory
could contain that number for other reasons, but choosing a value that can't be a pointer and that is high above 100 millions give us a fighting chance 
that the
probablity of hitting a bad positive is fairly low.
\item The length of the block. This will allow us to verify that nothing was written beyond the required length of the block.
\item A guard at the end of the block. We will ensure that we can read this quantity when freeing the block.
\end{enumerate}
\item We obtain memory using \texttt{malloc}. If not available we just return\Null.
\item We keep a counter of all memory allocated so far. This counter should be zero at program exit. It helps to detect the leaks between two 
operations: it suffices to note the value of the counter before some part of the software and then see if the counter returns to the
same value after the module has finished.
\item We write the two different integers at the start and at the end of the block, together with its size.
\item We set to zero all memory even if the program didn't ask us. This ensures that any error that accesses uninitialized memory will 
always have the same consequences.
\end{itemize}
The other functions that complete this memory manager (free, realloc calloc) are not shown here (they are available in the source code 
of the library). They just undo what \texttt{Malloc} has built, calling the error functions if they detect a problem.

This simple system has several drawbacks.
\begin{itemize}
\item If a buffer "underflow" happens, i.e. something is written to memory \textsl{before} the start of the block, our field "length" could be
wrong. Depending on the resulting contents of the length field after the overwrite we could have a bogus length and access some invalid memory.
\item Memory overwrites \textsl{after} the magic number that guards the end of the block are not detected. This is obviously impossible to detect
unless we would just inspect each memory write, but a few words more after the end of the block could give us some extra security.
\end{itemize}
%---------------------------------------------------------------------------------------------------------------------------------------
%                                             Templates
%---------------------------------------------------------------------------------------------------------------------------------------
\chapter{Building generic components}

If you take the source code of a container like “arraylist”, for instance, you will notice that all those “void *”are actually a single type, i.e. the type of the objects being stored in the container.  All generic containers use “void *” as the type under which the objects are stored so that the same code works with many different types.

Obviously another way is possible. You could actually replace the object type within that code and build a family of functions and types that can be specialized by its type parameter. For instance:
\begin{verbatim}
struct tag$(TYPE)ArrayInterface;
typedef struct _$(TYPE)Array {
   struct tag$(TYPE)ArrayInterface *VTable; 
   size_t count;
   unsigned int Flags;
   $(TYPE) *contents;
   size_t capacity;
   size_t ElementSize;
   unsigned timestamp;
   CompareFunction CompareFn; 
    ErrorFunction RaiseError;
} $(TYPE)_Array ;
\end{verbatim}
Now, if we just substitute \textbf{ \texttt{\$(TYPE)}} with \textbf{"double”} in the code above, we obtain:

\begin{verbatim}
struct tagdoubleArrayInterface;
typedef struct _doubleArray {
   struct tagdoubleArrayInterface *VTable; 
   size_t count;
   unsigned int Flags;
   double *contents;
   size_t capacity;
   size_t ElementSize;
   unsigned timestamp;
   CompareFunction CompareFn; 
    ErrorFunction RaiseError;
} double_Array ;
\end{verbatim}

We use the name of the parameter to build a family of names, and we use the name of the type parameter to declare an array of elements of that specific type as the contents of the array. This double usage allows us to build different name spaces for each different array type, so that we can declare arrays of different types without problems.

Using the same pattern, we can build a family of functions for this container that is specialized to a concrete type of element. For instance we can write:

\begin{verbatim}
static int EraseAt($(TYPE)_Array *AL,size_t idx)
{
        $(TYPE) *p;
        if (idx >= AL->count)
                return CONTAINER_ERROR_INDEX;
        if (AL->Flags & AL_READONLY)
                return CONTAINER_ERROR_READONLY;
        if (AL->count == 0)
                return -2;
        p = AL->contents+idx;
        if (idx < (AL->count-1)) {
                memmove(p,p+1,(AL->count-idx)*sizeof($(TYPE)));
        }
        AL->count--;
        AL->timestamp++;
        return AL->count;
}
\end{verbatim}

when transformed, the function above becomes:

\begin{verbatim}
static int EraseAt(double_Array *AL,size_t idx)
{
    double *p;
    if (idx >= AL->count)
        return CONTAINER_ERROR_INDEX;
    if (AL->Flags & AL_READONLY)
        return CONTAINER_ERROR_READONLY;
    if (AL->count == 0)
        return -2;
    p = AL->contents+idx;
    if (idx < (AL->count-1)) {
        memmove(p,p+1,(AL->count-idx)*sizeof(double));
    }
    AL->count--;
    AL->timestamp++;
    return AL->count;
}
\end{verbatim}

Now we can build a simple program in C that will do the substitution work for us. To make things easier, that program should build two files:
\begin{itemize}
\item The header file, that will contain the type definitions for our array.
\item The C source file, containing all the parametrized function definitions.
\end{itemize}
We separate the commands to change the name of the file from the rest of the text by introducing in the first positions of a line a sequence of three or more @ signs.  Normally we will have two of those “commands”: one for the header file, another for the c file.

Besides that, our program is just a plain text substitution. No parsing, nor anything else is required. If we write \texttt{"\$(TYPE)”} within a comment or a character string, it will be changed too.
\begin{verbatim}
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#define MAXLINE_LEN     2048
#define MAX_FNAME       1024
#define EXPANSION_LENGTH 256

int main(int argc,char *argv[])
{
   FILE *input,*output=NULL;
   char buf[MAXLINE_LEN],
        tmpLine[MAXLINE_LEN+EXPANSION_LENGTH];
   char tmpBuf[MAX_FNAME];
   char outputFile[MAX_FNAME];
   char *TypeDefinition;
   unsigned lineno = 1;

   if (argc < 3) {
      fprintf(stderr,
        "Usage: %s <template file to expand> <type name>\n",
              argv[0]);
         return EXIT_FAILURE;
   }
   input = fopen(argv[1],"r");
   if (input == NULL) {
       fprintf(stderr,"Unable to open file '%s'\n",argv[1]);
       return EXIT_FAILURE;
   }
   TypeDefinition = argv[2];
   while (fgets(buf,sizeof(buf)-1,input)) {
       if (buf[0]=='@' && buf[1] == '@' && buf[2] == '@') {
          int i=0,j=0;
          while (buf[i]  == '@')
                 i++;
          while (buf[i] != 0 && 
                 buf[i] != '\n' && 
                 i < MAX_FNAME-1) {
                   tmpBuf[j++] = buf[i];
                 i++;
           }
           tmpBuf[j] = 0;
           if (strrepl(tmpBuf,”$(TYPE)”,TypeDefinition,NULL)) {
                 fprintf(stderr,”File name '%s' too long\n”,
                                tmpBuf);
                 return EXIT_FAILURE;
           }
           strrepl(tmpBuf,"$(TYPE)",TypeDefinition,outputFile);
           if (output != NULL)
               fclose(output);
               output = fopen(outputFile,"w");
               if (output == NULL) {
                  fprintf(stderr,
                         "Impossible to open '%s'\n",outputFile);
                  return(EXIT_FAILURE);
               }
            }
            else if (lineno == 1) {
              fprintf(stderr,
              "Error: First line should contain the file name\n");
              exit(EXIT_FAILURE);
            }
            else {
             /* Normal lines here */
                if (strrepl(buf,"$(TYPE)",TypeDefinition,NULL) 
                     >= sizeof(tmpLine)) {
                 fprintf(stderr,
                      "Line buffer overflow line %d\n",lineno);
                       break;
                }
                strrepl(buf,"$(TYPE)",TypeDefinition,tmpLine);
                fwrite(tmpLine,1,strlen(tmpLine),output);
           }
           lineno++;
        }
        fclose(input);
        fclose(output);
        return EXIT_SUCCESS;
}
\end{verbatim}
The heart of this program is the “strrepl” function that replaces a given character string in a piece of text. If you call it with a\Null output parameter, it will return the number of characters that the replacement would need if any. For completeness, here is the code for strrepl:
\begin{verbatim}
int strrepl(const char *InputString, const char *StringToFind,
            const char *StringToReplace, char *output)
{
    char *offset = NULL, *CurrentPointer = NULL;
    int insertlen;
    int findlen = strlen(StringToFind);
    int result = 0;

    if (StringToReplace)
       insertlen = strlen(StringToReplace);
    else
       insertlen = 0;
    if (output) {
        if (output != InputString)
            memmove(output,InputString,strlen(InputString)+1);
            InputString = output;
    }
    else
       result = strlen(InputString)+1;

    while (*InputString)    {
    offset = strstr (!offset ? InputString : CurrentPointer,
                     StringToFind);
       if (offset == NULL)
           break;
       CurrentPointer = (offset + (output ? insertlen : findlen));
       if (output) {
           strcpy (offset, (offset + findlen));
           memmove (offset + insertlen,
                       offset, strlen (offset) + 1);
           if (insertlen)
               memcpy (offset, StringToReplace, insertlen);
           result++;
       }
       else {
           result -= findlen;
           result += insertlen;
       }
    }
    return result;
}
\end{verbatim}

And now we are done. The usage of this program is very simple:
 \begin{verbatim}
   expand <template file> <type name>
\end{verbatim}

For instance to substitute by “double” in the template file “arraylist.tpl” we would use:

\begin{verbatim}
   expand arraylist.tpl double
\end{verbatim}

We would obtain doublearray.h and doublearray.c

BUG: Obviously, this supposes that the type name does NOT contain  any spaces or other characters like '*' or “[  ]”. If you want to use types with those characters you should substitute them with a "\_” for instance, and make a typedef:

\texttt{typedef long double long\_double;}

And use that type ("long\_double”) as the substitution type.

\printindex
\end{document}
